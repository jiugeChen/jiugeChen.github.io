{"meta":{"title":"’’Sun--(*^▽^*)","subtitle":"","description":null,"author":"Chen jia","url":"http://jiugework.gitee.io"},"pages":[{"title":"关于我","date":"2019-07-11T08:35:59.193Z","updated":"2019-07-11T08:35:59.193Z","comments":true,"path":"about/index.html","permalink":"http://jiugework.gitee.io/about/index.html","excerpt":"","text":""},{"title":"timeline","date":"2019-07-10T14:03:53.000Z","updated":"2019-07-10T14:15:20.503Z","comments":true,"path":"timeline/index.html","permalink":"http://jiugework.gitee.io/timeline/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-07-10T14:26:50.234Z","updated":"2019-07-10T14:26:50.234Z","comments":true,"path":"gallery/index.html","permalink":"http://jiugework.gitee.io/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"Class类","slug":"js/Class","date":"2019-07-28T01:26:53.000Z","updated":"2019-07-28T01:29:38.951Z","comments":true,"path":"2019/07/28/js/Class/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/Class/","excerpt":"","text":"类的本质 class本质还是function 类的所有方法都定义在类的prototype属性上 类创建的实例,里面也有proto-指向类的prototype原型对象 所以ES6的类它的绝大部分功能, ES5都可以做到,新的class写法只是让对象原型的写法更加清晰、更像面向对编程的语法而已。 所以ES6的类其实就是语法糖. 语法糖语法糖就是一种便捷写法.简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便那么这个方法就是语法糖","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Class","slug":"Class","permalink":"http://jiugework.gitee.io/tags/Class/"}]},{"title":"面向对象","slug":"js/面向对象","date":"2019-07-28T01:26:53.000Z","updated":"2019-07-28T01:27:37.856Z","comments":true,"path":"2019/07/28/js/面向对象/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/面向对象/","excerpt":"","text":"创建对象的三中方式 利用new object()创建对象 1var obj1=new Object(); 利用 对象字面量创建对象 1var obj1=&#123;&#125; 通过构造函数创建对象 12345678function Star(name,sex)&#123; this.name = name; this.sex=sex; this.sing=function()&#123; console.log(\"唱歌\") &#125;&#125;var zxy= new Star('张学友','男');//实例化 new在执行会做四件事 在内存创建一个空对象 让this指向这个对象 执行构造函数里面的代码，给这个新对象添加属性以及方法 返回这个新对象 ） 实例成员和静态成员 实例成员就是构造函数内部通过this添加的成员，```sex``` sing12345- **实例成员**只能通过实例化的对象来访问```javascript console.log(zxy.name) 静态成员 在构造函数本身上添加的的成员就是静态成员 例如 1Star.age=18 静态成员只能通过构造函数来访问 12console.log(Star.sex)//能访问console.log(zxy.sex)//不能访问 prototype构造函数原型 构造函数通过原型分配的函数是所有对象所共享的。JavaScript规定,每一个构造函数都有一个prototype属性,指向另一个对象。注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。 123456789101112131415 function Star(name,sex)&#123; this.name = name; this.sex=sex; // this.sing=function()&#123; // console.log(\"唱歌\") //&#125; &#125;Star.prototype.sing=function()&#123; console.log(\"唱歌\") &#125; var zxy= new Star('张学友','男'); var cj= new Star('cj','男');zxy.sing===cj.sing //truezxy.sing() //唱歌 原型是什么? 一个对象,我们也称为prototype为原型对象 原型的作用是什么? 共享方法。 一般情况下,我们的公共属性定义到构造函数里面,公共的方法我们放到原型对象身上 对象原型proto对象都会有一个属性_proto_指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数 prototype原型对象的属性和方法,就是因为对象有proto原型的存在。 proto对象原型和 原型对象prototype是等价的* 1console.log(cj.__proto__===Star.prototype);//true 方法的查找规则: 首先先看ldh对象身上是否有sing方法,如果有就执行这个对象上的sing 如果么有sing这个方法,因为有一proto的存在,就去构造函数原型对象prototype身上去查找 sing这个方法 constructor构造函数对象原型(proto )和构造函数( prototype)原型对象里面都有一个属性constructor属性, constructor我们称为构造函数，因为它指回构造函数本身。 作用 constructor主要用于记录该对象引用于哪个构造函数,它可以让原型对象重新指向原来的构造函数 1234console.log(Star.prototype);console.log(ldh.proto_);console.log(star.prototype.constructor);console.log(ldh. proto_.constructor); 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor 123456789star.prototype =&#123; constructor: star , sing: function()&#123; console. log(' 我 歌');&#125;, movie: function() &#123; console.1og('我会演电影); &#125; &#125; 原型链JavaScript的成员查找机制(规则) 当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性。 如果没有就查找它的原型(也就是proto指向的prototype原型对象)。 如果还没有就查找原型对象的原型(Object的原型对象)。 依此类推一直找到Object为止(null )。 proto对象原型的意义就在于为对象成员查找机制提供一个方向,或者说一条路线。 给Array添加自定义方法12345Array.prototype.xx=()=&gt;&#123; console.log(\"xxxxxx\"); &#125; list.xx();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://jiugework.gitee.io/tags/面向对象/"}]},{"title":"Call","slug":"js/Call","date":"2019-07-28T01:26:53.000Z","updated":"2019-07-28T01:28:50.385Z","comments":true,"path":"2019/07/28/js/Call/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/Call/","excerpt":"","text":"Call用法 调用函数 123456function dr() &#123; console.log(\"play\"); console.log(this); //window &#125; dr.call() //play Call可以改变函数this的指向 12345678function dr() &#123; console.log(\"play\"); console.log(this); //指向o &#125; let o=&#123; name:'哈哈哈' &#125; dr.call(o) 此时这个函数的this就指向了o这个对象 123456789101112 function dr(x,y) &#123; console.log(\"play\"); console.log(this); //指向o console.log(x+y); &#125; let o=&#123; name:'哈哈哈' &#125; dr.call(o,1,2)// play// &#123;name: \"哈哈哈\"&#125;// 3 继承 继承属性 1234567891011121314//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex //把子的this传入到父 // this指向实例对象 Father.call(this, name, age) &#125;; let zs = new Son(\"张三\", 18, 'nan') console.log(zs); 继承方法 1Son. prototype = Father.prototype; //这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 12345678910111213141516171819202122232425//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; Father.prototype.money=function()&#123; console.log(\"钱\")&#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex Father.call(this, name, age) &#125;; Son.prototype=new Father(); //如果利用对象的形式修改来原型对象，别忘了利用 constructor指回原来的对象 Son.prototype.constructor=Son Son.prototype.play=function()&#123; console.log(\"吃饭\"); &#125; let zs = new Son(\"张三\", 18, 'nan'); zs.money(); zs.play(); console.log(zs); console.log(Father);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Call","slug":"Call","permalink":"http://jiugework.gitee.io/tags/Call/"}]},{"title":"Vue样式绑定方式","slug":"Vue/样式","date":"2019-07-22T12:33:15.236Z","updated":"2019-07-22T14:11:44.995Z","comments":true,"path":"2019/07/22/Vue/样式/","link":"","permalink":"http://jiugework.gitee.io/2019/07/22/Vue/样式/","excerpt":"","text":"第一种方式 直接传递一个数组 这里的class需要用v-bind绑定 12345678910111213141516171819&lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active&#123; letter-spacing: 0.5em; &#125; &lt;/style&gt; &lt;div id=\"app\"&gt;&lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; 第二种方式 通过三元表达式 12345678910111213141516171819 &lt;div id=\"app\"&gt;&lt;!-- &lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;1 --&gt;&lt;h1 :class=\"['red','active',flag?'thin':'']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; flag:true &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 第三种方式 把样式放到对象里把key为样式名，把value值绑定到一个bool值上 1&lt;h1 :class=\"['red','active',&#123;'thin':flag&#125;]\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; 第四种方式 传入一个对象本质跟第三种方法差不多 1&lt;h1 :class=\"&#123;red:flag,active:true,active:true&#125;\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; 或 123456789101112131415161718192021 &lt;div id=\"app\"&gt;&lt;!-- &lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;1 --&gt;&lt;!-- &lt;h1 :class=\"['red','active',flag?'thin':'']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;2 --&gt;&lt;h1 :class='classObj'&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; flag:true, classObj:&#123;red:true,active:true,active:true&#125; &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 内联样式 直接在元素123```html&lt;h1 :style=&quot;&#123;color:&apos;red&apos;,&apos;font-weight&apos;:200 &#125;&quot;&gt;变色&lt;/h1&gt; 在data中引用到:style 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=\"app\"&gt;&lt;h1 :style=\"styleObj1\"&gt;变色&lt;/h1&gt;&lt;!-- &lt;h1 :style=\"&#123;color:'red','font-weight':200 &#125;\"&gt;变色&lt;/h1&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; let vm = new Vue(&#123; el:'#app', data:&#123; styleObj1:&#123; color:'red','font-weight':200 &#125; &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 第三种绑定一个数组 123456789&lt;h1 :style=\"[ styleObj1,styleObj2 ]\"&gt;变色&lt;/h1&gt; data:&#123; styleObj1:&#123; color:'red','font-weight':200 &#125;, styleObj2:&#123; 'font-size':'60px' &#125; &#125;,","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"Vue样式","slug":"Vue样式","permalink":"http://jiugework.gitee.io/tags/Vue样式/"}]},{"title":"Vue指令","slug":"Vue/Vue指令","date":"2019-07-21T15:09:49.263Z","updated":"2019-07-22T13:54:16.015Z","comments":true,"path":"2019/07/21/Vue/Vue指令/","link":"","permalink":"http://jiugework.gitee.io/2019/07/21/Vue/Vue指令/","excerpt":"","text":"v-cloak 可以解决插值表达式闪烁问题 V-for 组件中使用v-for需要绑定key in后面可以放 数组，对象数组，对象，数字 循环普通数组 1&lt;h1 v-for=&quot;(item,i) in list &quot;&gt;&#123;&#123;item&#125;&#125;&lt;/h1&gt; 迭代数字 1&lt;h1 v-for=&quot;count in 10&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; v-html 可以渲染出带有标签的文本 v-if跟v-show show控制显示隐藏需要频繁切换建议使用 if控制是否渲染页面是否存在这个节点 v-text 可以解决插值表达式闪烁问题 v-bind 缩写 是“:” Vue的属性绑定机制 v-bind只能实现数据的单项绑定，只能从M绑定到V，无法实现数据的双向绑定 v-on Vue提供的事件绑定机制 缩写是“@” v-model 只能在表单元素中使用 实现双向数据绑定 使用v-model可以实现表单元素和model中数据的双向数据绑定 12&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;input type=\"text\" v-model:value=\"msg\" &gt; ​ 或者 1&lt;input type=\"text\" v-model=\"msg\" &gt; 案例 正式开发中尽量少用eval() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"n1\"&gt; &lt;select v-model=\"opt\"&gt; &lt;option v-for=\"item in list\" :key=\"item.index\"&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" v-model=\"n2\" bu&gt; = &lt;input type=\"text\" v-model=\"result\" @focus=\"comp\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; n1: '', n2: '', opt: '-', result: '', list: ['+', '-', '*', '/'] &#125;, methods: &#123; comp() &#123; let result=this.n1+this.opt+this.n2 this.result= eval(result) // switch (this.opt) &#123; // case '+': // this.result = Number(this.n1) + Number(this.n2) // break; // case '-': // this.result = Number(this.n1) - Number(this.n2) // break; // case '/': // this.result = Number(this.n1) / Number(this.n2) // break; // case '*': // this.result = Number(this.n1) * Number(this.n2) // break; // default: // break; // &#125; &#125; &#125;, &#125;)&lt;/script&gt; 事件修饰符 .stop阻止冒泡（ 里–》外） .prevent阻止默认事件（） .capture添加事件监听器时使用事件捕获模式（外–&gt;里） .self只当事件在该元素（比如不是子元素）触发是触发回调(自己触发自己，) 只会阻止自己冒泡，并不会阻止其他的冒泡 .once事件只触发一次","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"指令","slug":"指令","permalink":"http://jiugework.gitee.io/tags/指令/"}]},{"title":"数组中常用的方法","slug":"js/数组","date":"2019-07-19T13:15:26.048Z","updated":"2019-07-27T07:41:11.509Z","comments":true,"path":"2019/07/19/js/数组/","link":"","permalink":"http://jiugework.gitee.io/2019/07/19/js/数组/","excerpt":"","text":"开发中数组的使用场景非常多, 这里就简单整理总结一些常用的方法;从改变原有数据的方法、不改变原有数组的方法以及数据遍历的方法三方面总结。 改变原有数组的方法splice() 添加/删除数组元素 1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]// 从0开始截取到第三个位置console.log(a); // [4,5,6,7]let item1 = a.splice(0,3,'添加'); // [4,5,6]console.log(a); // ['添加',7]// 从数组下标0开始，删除3个元素，并添加元素'添加' sort() 数组排序1234567891011var array = [10, 1, 3, 4,20,4,25,8]; // 升序 a-b &lt; 0 a将排到b的前面，按照a的大小来排序的 array.sort(function(a,b)&#123; return a-b; &#125;); console.log(array); // [1,3,4,4,8,10,20,25]; // 降序 array.sort(function(a,b)&#123; return b-a; &#125;); console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 shift() 删除数组的第一个元素 push() 向数组的末尾添加元素 unshift()向数组开头添加元素 reverse()1234567891011let a = [1,2,3]; a.pop(); // 3, 返回被删除的元素 console.log(a); // [1,2] a.shift(); // 1 console.log(a); // [2] a.push(\"末尾添加\"); // 2 ,返回数组长度 console.log(a) ; [2,\"末尾添加\"] a.unshift(\"开头添加\"); // 3 console.log(a); //[\"开头添加\", 2, \"末尾添加\"] a.reverse(); // [\"末尾添加\", 2, \"开头添加\"] console.log(a) // [\"末尾添加\", 2, \"开头添加\"] copyWithin() 指定位置的成员复制到其他位置1234let a = ['zhang', 'wang', 'zhou', 'wu', 'zheng']; // 1位置开始被替换, 2位置开始读取要替换的 5位置前面停止替换 a.copyWithin(1, 2, 5); // [\"zhang\", \"zhou\", \"wu\", \"zheng\", \"zheng\"] ES6: fill() 填充数组1234['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 以上是9种会改变原数组的方法, 接下来是6种常用的不会改变原数组的方法 不改变原数组的方法join() 数组转字符串12let a= ['hello','world']; let str2=a.join('+'); // 'hello+world' cancat 合并两个或多个数组1234let a = [1, 2, 3]; let b = [4, 5, 6]; //连接两个数组 let newVal=a.concat(b); // [1,2,3,4,5,6] ES6扩展运算符…合并数组1234let a = [2, 3, 4, 5] let b = [ 4,...a, 4, 4] console.log(a,b); //[2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标123let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1console.log(a.indexOf('啦啦')); // 0 ES7 includes() 查找数组是否包含某个元素 返回布尔 indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观1234let a=['OB','Koro1',1,NaN]; a.includes(NaN); // true 识别NaN a.includes('Koro1',100); // false 超过数组长度 不搜索 a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 slice() 浅拷贝数组的元素 字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。1234567let a = [&#123;name: 'OBKoro1'&#125;, &#123;name: 'zhangsan'&#125;]; let b = a.slice(0,1); console.log(b, a); // [&#123;\"name\":\"OBKoro1\"&#125;] [&#123;\"name\":\"OBKoro1\"&#125;] a[0].name='改变原数组'; console.log(b,a); // [&#123;\"name\":\"改变原数组\"&#125;] [&#123;\"name\":\"改变原数组\"&#125;]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://jiugework.gitee.io/tags/数组/"},{"name":"Array","slug":"Array","permalink":"http://jiugework.gitee.io/tags/Array/"}]},{"title":"常用CSS样式","slug":"css/css1","date":"2019-07-16T09:21:34.109Z","updated":"2019-07-16T09:34:05.772Z","comments":true,"path":"2019/07/16/css/css1/","link":"","permalink":"http://jiugework.gitee.io/2019/07/16/css/css1/","excerpt":"","text":"CSS超出部分显示省略号12345678910111213141516171819202122232425/* 单行 */.overflow&#123; overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125;/* 多行 */.more_overflow&#123;display: -webkit-box;text-overflow: ellipsis;-webkit-box-orient: vertical;-webkit-line-clamp: 2; /* 显示行数 */overflow: hidden;&#125;## css元素垂直居中```css.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; banner自适应屏幕代码123456789101112div &#123; width:100%; position:relative; overflow:hidden; height:200px;&#125;img &#123; width:3000px;/*图片宽度*/ position:absolute; left:50%; margin-left:-1500px;/*图片宽度的一半*/ &#125; `","categories":[{"name":"Css","slug":"Css","permalink":"http://jiugework.gitee.io/categories/Css/"}],"tags":[{"name":"常用CSS","slug":"常用CSS","permalink":"http://jiugework.gitee.io/tags/常用CSS/"}]},{"title":"字符串常用操作","slug":"js/字符串常用操作","date":"2019-07-11T09:02:07.077Z","updated":"2019-07-28T01:41:33.495Z","comments":true,"path":"2019/07/11/js/字符串常用操作/","link":"","permalink":"http://jiugework.gitee.io/2019/07/11/js/字符串常用操作/","excerpt":"","text":"判断开头结尾 startsWidth判断以什么开头 endsWidth判断以什么结尾 1let str='https://www.4399.com'; // alert(str.startsWith('a')) //判断是否以'a'开头，返回bool值 endsWidth同理 判断包含 includes判断是够包含某个字符串 返回bool值 indexOf判断是否包含并且返回下标，不存在返回-1 1234567let str = '123456';str.includes('456') //truestr.includes('46') //falsestr.indexOf(\"1\") //0 //存在str.indexOf(\"45\") //3 //存在str.indexOf(\"46\") //-1 //不存在 字符串截取 slice substring substr 12345678910111213141516let str = 'abcdef';str = str.slice(0);//返回整个字符串 abcdefstr = str.substring(0);//返回整个字符串 abcdefstr = str.substr(0);//返回整个字符串 abcdef// 使用一个参数str = str.slice(2);//截取第二个之后所有的字符 cdefstr = str.substring(2);//截取第二个之后所有的字符 cdefstr = str.substr(2);//截取第二个之后所有的字符 cdef// 使用两个参数str = str.slice(2,4);//截取第二个到第四个之间的字符 cdstr = str.substring(2,4);//截取第二个到第四个之间的字符 cd 前下标str = str.substr(2,4);//截取从第3个开始往后数4位之间的字符 cdef// 使用两个负数str = str.slice(1,-3);//截取第二个到倒数第三个str = str.substr(1,-3);//不能为负数，若强行传递负数，会被当成0处理 ' ' #负数转换为0 字符串和数组相互转换 split join 123456789// 字符串转数组let str = \"abc,abcd,aaa\";t = str.split(\",\");// 在每个逗号(,)处进行分解 [\"abc\", \"abcd\", \"aaa\"]var str = \"helloworld\";t1 = str.split(''); //[\"h\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\"]// 数组转字符串var a, b;a = new Array(0,1,2,3,4);b = a.join(\"-\"); //\"0-1-2-3-4\"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"String","slug":"String","permalink":"http://jiugework.gitee.io/tags/String/"},{"name":"字符串","slug":"字符串","permalink":"http://jiugework.gitee.io/tags/字符串/"}]},{"title":"模板","slug":"js/1bbbbb","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-28T01:46:26.346Z","comments":true,"path":"2019/07/05/js/1bbbbb/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/js/1bbbbb/","excerpt":"","text":"#模板","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"模板","slug":"js/1bbbbb (copy)","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-28T01:39:49.318Z","comments":true,"path":"2019/07/05/js/1bbbbb (copy)/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/js/1bbbbb (copy)/","excerpt":"","text":"#模板","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"函数进阶","slug":"js/函数进阶","date":"2018-07-27T14:42:09.000Z","updated":"2019-07-28T08:21:19.471Z","comments":true,"path":"2018/07/27/js/函数进阶/","link":"","permalink":"http://jiugework.gitee.io/2018/07/27/js/函数进阶/","excerpt":"","text":"函数的定义和调用函数定义方式 函数声明方式function关键字(命名函数) 函数表达式(匿名函数) Function里面参数都必须是字符串格式 第三种方式执行效率低,也不方便书写,因此较少使用 所有函数都是Function的实例(对象) 函数属于对象 new Function（’par1’,’par2’…’par..‘,’函数体’） 12let f = new Function('a','b','console.log(a+b)')f(1,2);//3 函数调用方式 普通函数 对象的方法 构造函数 绑定事件函数 定时器函数 立即执行函数 函数this的指向 这些this的指向,是当我们调用函数的时候确定的。调用方式的不同决定了this的指向不同一般指向我们的调用者 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象原型对象里面的方法也指向实例对象 对象方法调用 该方法属于所属对象 事件绑定方法 事件绑定对象 定时器函数 window 立即执行函数 window JavaScript为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部this的指向问题,常用的有bind.call, apply三种方法。 call方法 改变this指向 调用函数 例 1234567891011121314151617181920212223//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; Father.prototype.money=function()&#123; console.log(\"钱\")&#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex Father.call(this, name, age) &#125;; Son.prototype=new Father(); //如果利用对象的形式修改来原型对象，别忘了利用 constructor指回原来的对象 Son.prototype.constructor=Son Son.prototype.play=function()&#123; console.log(\"吃饭\"); &#125; let zs = new Son(\"张三\", 18, 'nan'); zs.money(); zs.play(); console.log(zs); console.log(Father); apply apply方法调用一个函数。简单理解为调用函数的方式,但是它可以改变函数的this指向。 fun.apply(thisArg,[argArray]) thisArg :在fun函数运行时指定的this值 argsArray :传递的值,必须包含在数组里面 返回值就是函数的返回值,因为它就是调用函数 也是调用函数第二个可以改变函数内部的this指向 但是他的参数必须是数组(伪数组) apply的主要应用比如说我们可以利用apply借助于数学内置对象求最大值 123let list=[1,1,5,5,4,54,54,5,48884,4,4545,]; let res= Math.max.apply(Math,list); console.log(res); //48884 bind bind()方法不会调用函数。但是能改变函数内部this指向 fun.bind(thisArg,arg1,arg2...) thisArg :在fun函数运行时指定的this值 arg1 , arg2:传递的其他参数 返回由指定的this值和初始化参数改造的原函数拷贝 1234567891011121314151617 //1let o = &#123; name: '进阶'&#125; function fn() &#123; console.log(this); &#125; let newFn = fn.bind(o); fn(); //指向 --&gt;window newFn(); //指向o//2 let o = &#123; name: '进阶'&#125; function fn(a,b) &#123; console.log(this); console.log(a,b); &#125; let newFn = fn.bind(o,'哈哈','嘻嘻'); fn(); //指向 --&gt;window newFn(); //指向o 返回的是原函数改变this之后产生的新函数 如果有的函数我们不需要立即调用 但是又想改变这个函数内部的this指向此时用bind 例如： 1234567891011121314151617181920212223242526272829303132let btn =document.querySelectorAll('input')[0]btn.onclick=function()&#123; this.disabled=true; this.value='禁用' // setTimeout(()=&gt;&#123; // this.disabled=false // &#125;,3000) setTimeout(function () &#123; this.disabled=false this.value='点击' &#125;.bind(this),3000)&#125;//2.扩展&lt;body&gt; &lt;input type=\"button\" value=\"点击1\"&gt; &lt;input type=\"button\" value=\"点击2\"&gt; &lt;input type=\"button\" value=\"点击3\"&gt; &lt;script&gt; let btns = document.querySelectorAll('input'); for (let i = 0; i &lt; btns.length; i++) &#123; console.log(this); btns[i].onclick = function () &#123; this.disabled = true; this.value = '禁用'+(i+1); setTimeout(function () &#123; this.disabled = false this.value = '点击'+(i+1) &#125;.bind(this), 3000) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 总结相同点： 都可以改变函数内部this指向 区别点: call和apply会调用函数,并且改变函数内部this指向 call和apply传递的参数不一样,call传递参数arg1, arg2.形式apply必须数组形式[arg] bind不会调用函数,可以改变函数内部this指向 主要应用场景: call常做继承. apply经常跟数组有关系.比如借助于数学对象实现数组最大值最小值 bind不调用函数,但是还想改变this指向,比如改变定时器内部的this指向 严格模式JavaScript除了提供正常模式外,还提供了严格模式(strictmode ) , ES5的严格模式是采用具有限制性 Javascript变体的一种方式,即在严格的条件下运行IS代码。 消除了Javascript语法的一些不合理、不严谨之处,减少了一些怪异行为。 消除代码运行的一些不安全之处,保证代码运行的安全。 提高编译器效率,增加运行速度。 禁用了在ECMAScript的未来版本中可能会定义的一些语法,为未来新版本的Javascript做好铺垫。比如一些保留字如: class, enum, export, extends, import, super 不能做变量名 this指向问题 以前在全局作用域函数中的this指向window对象。 严格模式下全局作用域中函数中的this是undefined. 以前构造函数时不加new也可以调用,当普通函数, this指向全局对象 严格模式下,如果构造函数不加new调用, thi指向undefined给他赋值会报错 new实例化的构造函数指向创建的对象实例。 定时器this还是指向window 事件.对象指向调用者 函数变化 函数不能有重名的参数。 函数必须声明在顶层新版本的JavaScript会引入”块级作用域” (ES6中已引入)。为了与新版本接轨,不允许在非函数的代码块内声明函数。 高阶函数 高阶函数是对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出。 12345678fn1 = function () &#123; console.log(\"最后调用\"); &#125; function fn(a, b, callback) &#123; console.log(a + b); callback &amp;&amp; callback() &#125; fn(1, 2, fn1); 此时fn就是一个高阶函数 函数也是一种数据类型,同样可以作为参数,传递给另外一个参数使用。最典型的就是作为回调函数。 闭包 闭包(closure )指有权访问另一个函数作用域中变量的函数—– JavaScript高级程序设计。 简单理解就是,一个作用域可以访问另外一个函数内部的局部变量。 1234567891011121314 function fn() &#123; var num =10; return function (params) &#123; console.log(num); &#125;; &#125; var f= fn(); f()//类似于f= function (params) &#123; console.log(num); &#125;;f(); 闭包的作用：延伸了变量的作用范围 闭包案例 循环注册点击事件 注意这里for里面是用var声明的 123456789101112131415&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; &lt;script&gt; let lis= document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; (function(i)&#123; lis[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i); &#125; &lt;/script&gt; 循环setTimeout 3秒之后打印出li元素的所有内容 123456789 let lis= document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123;(function(a)&#123; setTimeout(function()&#123; console.log(lis[a].innerHTML); &#125;,3000) &#125;)(i); &#125;//1 2 3 闭包总结 什么是闭包 ​ 闭包是一个函数(一个作用域可以访问另外一个函数的局部变量) 闭包的作用是是嗯嘛 延伸变量的作用范围 递归什么是递归? 如果一个函数在内部可以调用其本身,那么这个函数就是递归函数。 简单理解:函数内部自己调用自己这个函数就是递归函数 递归函数的作用和循环效果一样 由于递归很容易发生”栈溢出”错误(stackoverflow ) ,所以必须要加退出条件return 12345678let num = 0; function fn() &#123; num++; console.log(num); if (num &gt;= 10) return num fn() &#125; fn(); 利用递归求阶乘 12345678function fn(n) &#123; if (n == 1) &#123; return n &#125; return n * fn(n - 1) &#125; f = fn(3); console.log(f); 利用递归函数求斐波那契数列(兔子序列) 1234567 function fb(n) &#123; if(n==1||n==2)&#123; return 1; &#125; return fb(n - 1) + fb(n - 2) &#125;console.log( fb(6));//8 拷贝浅拷贝 浅拷贝只是拷贝最外面一层,更深层次对象级别的只拷贝引用. 浅拷贝只是拷贝最外面一层，更深的只是拷贝的地址 Object.assign(target….sources) es6新增方法可以浅贝 深拷贝 深拷贝拷贝多层每一级别的数据都会拷贝 深拷贝会复制一个空间/地址 1234567891011121314151617181920212223242526let od = &#123; name:'18', sex:&#123; sex:88888 &#125;&#125;let ne=&#123;&#125;//封装 function deepCopy(newobj, oldobj) &#123; for (let k in oldobj) &#123; let item = oldobj[k]; if (item instanceof Array) &#123; deepCopy(newobj[k], item) &#125; else if (item instanceof Object) &#123; newobj[k] = &#123;&#125;; deepCopy(newobj[k], item) &#125;else&#123; newobj[k]=item &#125; &#125; &#125;deepCopy(ne,od);console.log(od);console.log(ne);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"函数进阶","slug":"函数进阶","permalink":"http://jiugework.gitee.io/tags/函数进阶/"}]},{"title":"数据交互","slug":"data/数据交互","date":"2018-07-11T08:25:28.000Z","updated":"2019-07-11T09:56:39.965Z","comments":true,"path":"2018/07/11/data/数据交互/","link":"","permalink":"http://jiugework.gitee.io/2018/07/11/data/数据交互/","excerpt":"","text":"http协议 无状态 连接过程：连接-接受-发送请求 消息分成两部分，请求头&lt;=32K、请求体&lt;=2G form 最重要 action-提交到的位置 method–GET/POST/PUT/DELETE/HEAD GET: 把数据放在url传输 数据量很小、缓存。获取东西 POST: 把数据放在请求体里面 数据量大、不会缓存。发送东西，大量发送。 PUT:发送东西，大量发送。 DELETE:删除。 HEAD:让服务器只发送头回来就行(不需要内容) name 名字 enctype 上传文件需要设置的 ajax 官方、不能跨域 单向 ajax好: 用户体检好，性能高原理 ajax-jsonp 民间、能跨域 不推荐 破坏了http自身的设计websocket 双向-数据实时性 html5 IE9+ 用的非常广 基于http 跨域 原生麻烦socket.io: 兼容的？ 二进制数据 怎么用 聊天室 视频点播socket.io 安装npm i socket.io -D websocket聊天室 用户注册、登陆 发言 离线消息 数据 用户信息库 消息数据库 数据库 关系形数据库—— MySQL、Oracle 优点 : 强大 缺点 : 性能低 文件形数据库—— SQLite 优点 : 简单 缺点 : 支撑不了庞大的应用、没法储存特别多的数据 文档形数据库—— MongoDB 优点 : 直接存储对象本身 缺点 : 不够严谨、性能偏低 空间形数据库—— 坐标、位置 .. GIS 数据库类型: 数字 整数 thinyint(-128~127或者0~255)、int(21亿或43亿); 浮点数 float（保留到小数点8位） 、 double（308） 字符串 小字符串 varchar（255） 大字符串 text（2G） 主键: 唯一 性能高","categories":[],"tags":[{"name":"请求数据","slug":"请求数据","permalink":"http://jiugework.gitee.io/tags/请求数据/"},{"name":"ajax","slug":"ajax","permalink":"http://jiugework.gitee.io/tags/ajax/"}]},{"title":"ES5中新增的方法","slug":"js/对象","date":"2018-07-08T09:27:42.000Z","updated":"2019-07-27T08:30:25.299Z","comments":true,"path":"2018/07/08/js/对象/","link":"","permalink":"http://jiugework.gitee.io/2018/07/08/js/对象/","excerpt":"","text":"对象方法Object.defineProperty（）定义对象中新属性或修改原有的属性。 Object.defineProperty（obj,prop,des） obj:必需。目标对象 prop :必需。需定义或修改的属性的名 descriptor :必需。目标属性所拥有的特性 Object.defineProperty()第三个参数descriptor说明:以对象形式(}书写 value:设置属性的值默认为undefinedwritable:值是否可以重写truel false默认为false enumerable:目标属性是否可以被枚举。true | false默认为false configurable:目标属性是否可以被删除或是否可以再次修改特性true | false默认为false Object.keys()用于获取对象自身所有的属性 12345let obj=&#123; name:'小米', age:9, &#125; console.log( Object.keys(obj));//[\"name\", \"age\"]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES5新增方法","slug":"ES5新增方法","permalink":"http://jiugework.gitee.io/tags/ES5新增方法/"}]},{"title":"数据遍历","slug":"js/遍历方法","date":"2018-07-08T09:27:42.000Z","updated":"2019-07-27T13:49:53.891Z","comments":true,"path":"2018/07/08/js/遍历方法/","link":"","permalink":"http://jiugework.gitee.io/2018/07/08/js/遍历方法/","excerpt":"","text":"map 映射 一个对一个 123456789101112 [12,58,60,60,99,8] [\"不及格\",\"不及格\",\"及格\",\"及格\",\"及格\",\"不及格\"];// 1.使arr中数字乘以2，输出结果let arr = [12, 5, 8];let result = arr.map(item =&gt; item * 2)console.log(result);//(3) [24, 10, 16]// ////////////////////// 2.分数大于等于60的输出及格,小于60的输出不及格let mark = [15, 88, 76, 60, 55];let markResult = mark.map(item=&gt; item &gt;= 60 ? \"及格\" : \"不及格\")console.log(markResult);//[\"不及格\", \"及格\", \"及格\", \"及格\", \"不及格\"] reduce 汇总 一堆出来一个1234567891011121314151617// 1.算个总数 [10,20,30] =&gt; 60;// 2.算个平均数 [10,20,30] =&gt; 20; let arr = [12, 541, 5461, 115, 656]; let arrRes = arr.reduce((tmp, item, index) =&gt; tmp + item)console.log(arrRes);//6785//2.算个平均数let avgRes = arr.reduce((tmp, item, index) =&gt; &#123; if (index != arr.length - 1) &#123; return tmp + item &#125; else &#123; return (tmp + item) / arr.length; &#125;&#125;)console.log(avgRes);//1357 filterarray.filter(function(currentValue,index,arr){}) filter方法创建一个新的数组,新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛造数组 注意它直接返回一个新数组 不会收到return的影响 currentValue:数组当前项的值 index数组当前项的索 arr:数组对象本身 12345678910111213 // 1.算出能被3整除的数let arr = [12, 541, 5461, 115, 656, 99, 30];let result = arr.filter(item =&gt; item%3==0)console.log(result); //(3) [12, 99, 30]// 2.价格大于10000的数据let arrz=[ &#123;title:'男鞋',price:650&#125;, &#123;title:'女鞋',price:15000&#125;, &#123;title:'男装',price:100&#125;, &#123;title:'女装',price:10000&#125;]let pres = arrz.filter(item=&gt;item.price&gt;=10000);console.log(pres);// &#123;title:'女鞋',price:15000&#125;, &#123;title:'女装',price:10000&#125; fofEach 循环(迭代) orEach这种方法也有一个小缺陷：你不能使用break语句中断循环，也不能使用return语句返回到外层函数。 forEach(function(value,索引，数组本身){}) 12let arr = [12, 541, 99, 30]; arr.forEach(item=&gt; console.log(item)) Somearray.some(function(currentValue,index,arr)) some方法用于检测数组中的元素是否满足指定条件,通俗点查找数组中是否有满足条件的元素 注意它返回值是布尔值,如果查找到这个元素,就返回true,如果查找不到就返回false. 如果找到第一个满足条件的元素,则终止循环不在继续查找 currentValue:数组当前项的值 index:数组当前项的索引 arr :数组对象本身 123let arr = [12, 541, 656, 99, 30]; let res= arr.some(item=&gt;item==12); console.log(res); //true 123456789101112let arr = [111,12, 541, 5461, 115, 656, 99, 30]; let res = arr.some(item =&gt; &#123; if (item == 12) &#123; console.log(\"找到来\"); return true; //找到了记得return 不然他会找把整个数组找完 &#125; console.log(\"寻找\"); &#125; ); console.log(res); 数组遍历普通for循环，经常用的数组遍历12345var arr = [1, 3, 45, 7, 'dd'];for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125;// 打印结果 1 3 45 7 dd 优化版for循环:使用变量，将长度缓存起来，避免重复获取长度，数组很大时优化效果明显 12345var arr = [1, 3, 45, 7, 'dd'];for(var j= 0, len = arr.length; j&lt;len; j++)&#123; console.log(arr[j]); &#125;// 打印结果 1 3 45 7 dd map遍历 map即是 “映射”的意思 用法与 forEach 相似 12345678910 var arr = [1, 3, 45, 7, 'dd'];arr.map(function(value,i)&#123; console.log(i+'--'+value);&#125;)// 打印结果// 0--1// 1--3 // 2--45 // 3--7 // 4--dd map遍历支持使用return语句，支持return返回值1234567var arr = [1, 3, 45, 7, 'dd'];var b= arr.map(function(value,i)&#123; console.log(i+'--'+value); return value;&#125;)console.log(b);// b返回 (5) [1, 3, 45, 7, \"dd\"] for-of遍历 是ES6新增功能12345var arr = [1, 3, 45, 7, 'dd'];for( let i of arr)&#123; console.log(i);&#125;// 打印结果: 1 3 45 7 dd for-of这个方法避开了for-in循环的所有缺陷 与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不仅支持数组，还支持大多数类数组对象 for-of循环也支持字符串遍历","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"},{"name":"遍历","slug":"遍历","permalink":"http://jiugework.gitee.io/tags/遍历/"},{"name":"循环","slug":"循环","permalink":"http://jiugework.gitee.io/tags/循环/"}]},{"title":"Promise","slug":"js/Promise","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:15:58.112Z","comments":true,"path":"2018/07/05/js/Promise/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/Promise/","excerpt":"","text":"异步: 操作直接没啥关系,同时进行多个操作，代码复杂。 同步: 同时只能做一件事 代码简单。 本质：等待异步操作结束 当状态改变的时候—调用之前挂起的then队列 then的时候直接执行对应的函数，并且参数给人家。 Promise 用法Promise.all 一个都不能错Promise.race 只要有一个对 一个 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise(function (resolve, reject) &#123; //异步代码 //resolve 成功 //reject 失败 $.ajax(&#123; url: \"data/tt.txt\", dataType: \"json\", success: function (data) &#123; resolve(data) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;) p.then(function (data) &#123; alert('成功' + data) // 调用成功 &#125;, function (err) &#123; console.log(err); alert('失败') //失败了 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function createPromise(url) &#123; return new Promise(function (resolve, reject) &#123; //异步代码 //resolve 成功 //reject 失败 $.ajax(&#123; url, dataType: \"json\", success: function (data) &#123; resolve(data) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;) &#125; Promise.all([ createPromise('data/tt.txt'), createPromise('data/jj.txt') ]).then(function (arr) &#123; // 全部成功 alert('成功'); let [arr1, arr2] = arr; console.log(arr); console.log(arr1); console.log(arr2); &#125;, function (err) &#123; //失败一个或多个 alert('失败'); console.log(err); &#125;) &lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123; url: 'data/tt.txt', dataType: \"json\" &#125;), $.ajax(&#123; url: 'data/jj.txt', dataType: \"json\" &#125;) ]) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jq中的promise 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url:'data/tt.txt',dataType: \"json\"&#125;), $.ajax(&#123;url:'data/jj.txt',dataType: \"json\"&#125;) ]).then(function (arr) &#123; let [arr1,arr2] = arr; alert('成功'); console.log(arr); console.log(arr1); console.log(arr2); &#125;,function () &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"}]},{"title":"模块化","slug":"js/模块化","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:53:42.647Z","comments":true,"path":"2018/07/05/js/模块化/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/模块化/","excerpt":"","text":"模块化 模块-组件-元件 模块： 12345678910// - 定义: model.js define(function (require,exports,module) &#123; exports.a = 12; exports.b=5;&#125;); // - 调用: xx.htmlseajs.use(['xxxx.js','xxx.js',...],function(model1,model2,...)&#123;&#125;) 民间的–sea.js 、require.js CMD、AMD规范 区别： html-&gt;js use js-&gt; js require node.js模块化 没有define exports、require、module 引用自定义模块 1) 放到node_modules里, 2)前面加上./ 引入: let mod = require(‘./aaa.js’) 输出: exports.xx = xxx; module.exports={x,x,x,y} ES6模块化 import export 引入:impo mod from = ‘./xx.js’ 输出:expor{x,x,x}","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"模块化","slug":"模块化","permalink":"http://jiugework.gitee.io/tags/模块化/"}]},{"title":"箭头函数","slug":"js/箭头函数","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:53:42.648Z","comments":true,"path":"2018/07/05/js/箭头函数/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/箭头函数/","excerpt":"","text":"之前的函数是这样写的 123function 名字()&#123; // code&#125; 而ES6是↓ 箭头函数 如果只有一个参数，()可以省略 如果只有一个return {}可以省略 1234567891011121314151617()=&gt;&#123; &#125;;window.onload= ()=&gt; alert('vb');let show=function()&#123; console.log(\"666\");&#125;;let show=()=&gt;&#123; console.log(\"666\");&#125;;let add = function(a,b)&#123; alert(a+b);&#125;let add = (a,b)=&gt;&#123; alert(a+b);&#125;add(1,6) 函数-有参数 参数扩展/展开 收集参数 收集剩余的参数 …args必须是最后一个123456789function arg(a,b,...args) &#123; console.log(a); console.log(b); console.log(...args);&#125;arg(1,2,5,7,9,2,10); // 1// 2// 5 7 9 2 10 展开参数 12345678910111213141516171819202122232425 let array = [1,55,5]function zhan(a,b,c) &#123; console.log(a); console.log(b); console.log(c);&#125;zhan(...array) //1//55//5//////////////////////////////////let arr1=[1,2,5];let arr2=[10,22,52];let arr3 = [...arr1,...arr2];console.log(arr3);// (6) [1, 2, 5, 10, 22, 52]////////////////////////////////// function a(...args)&#123; fadd(...args) &#125; function fadd(a,b) &#123; console.log(a+b); &#125; a(1,6)//7 默认参数 123456function m(a,b=1,c=10) &#123; console.log(a,b,c); &#125; m(1) //1 1 10 m(1,2)//1 2 10 m(1,2,5)// 1 2 5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"}]},{"title":"解构赋值","slug":"js/结构赋值","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:55:59.502Z","comments":true,"path":"2018/07/05/js/结构赋值/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/结构赋值/","excerpt":"","text":"结构赋值 左右两边结构必须一样; 右边必须是个东西; 声明和赋值不能分开(必须在一句话里说完);12345678 // 数组let [aq,bq,cq]=[1,2,3]; console.log(aq);//1 console.log(bq);//2 console.log(cq);//3 // 对象 let &#123;w,z,y&#125; = &#123;w:12,z:66,y:15&#125;; console.log(w,z,y);// 12 66 15","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"}]},{"title":"generator","slug":"js/generator","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:33:28.680Z","comments":true,"path":"2018/07/05/js/generator/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/generator/","excerpt":"","text":"generatorgenerator-生成器 普通函数- 一路到底 generator函数- 中间可以停 走走停停 12345678910 function *show() &#123; alert('a'); yield; alert('b') &#125; show(); let gentObj = show(); gentObj.next(); //a gentObj.next();//bconsole.log(gentObj) generator-yield是什么 可以传参、可以返回 …..本质：无感觉处理异步操作","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"Git常用操作","slug":"GIt操作","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-18T08:39:59.351Z","comments":true,"path":"2018/07/05/GIt操作/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/GIt操作/","excerpt":"","text":"初始化git config --global user.name &quot;你的账号&quot; git config --global user.email &quot;你的邮箱&quot; 在文件中初始化Git（创建Git仓库）git init 提交仓库 创建文件 git touch a1.html 文件提交到暂存区 git add a1.html 文件提交描述 git commit -m &#39;描述&#39; 查看文件状态 git status 提交到仓库 git push Git克隆操作 git clone 仓库地址 新仓库添加本地文件 新建码云/github仓库 本地新建文件夹 新建的文件夹，点击鼠标右键，选择git bash here git init 复制项目地址 然后git remote add origin 地址 继续输入git pull origin master 命令，将码云上的仓库pull到本地文件夹 使用git add -A （. 表示所有的）或者 git add + 文件名 // 将文件保存到缓存区 使用git commit -m‘新添加的文件内容描述’ //添加文件描述 使用git push origin master ，将本地仓库推送到远程仓库 ok了","categories":[{"name":"Git","slug":"Git","permalink":"http://jiugework.gitee.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jiugework.gitee.io/tags/Git/"}]},{"title":"变量let与常量const","slug":"js/变量与常量","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:35:16.826Z","comments":true,"path":"2018/07/05/js/变量与常量/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/变量与常量/","excerpt":"","text":"变量let与常量const ES5 var 问题 可以重复声明 无法限制修改 没有块级作用域 ES6 变量 let 不能重复声明 可以重新定义 有块级作用域 ES6 常量 const 不能重复声明 不可以重新定义 有块级作用域","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"变量","slug":"变量","permalink":"http://jiugework.gitee.io/tags/变量/"}]},{"title":"Number","slug":"js/number","date":"2018-07-05T10:01:48.000Z","updated":"2019-07-24T03:13:34.007Z","comments":true,"path":"2018/07/05/js/number/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/number/","excerpt":"","text":"保留2位小数 四舍五入 12var num =2.446242342;num = num.toFixed(2); // \b输出结果为 2.45 不四舍五入 1Math.floor(15.7784514000 * 100) / 100 // \b输出结果为 15.77","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Number","slug":"Number","permalink":"http://jiugework.gitee.io/tags/Number/"}]}]}