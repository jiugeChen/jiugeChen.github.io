{"meta":{"title":"’’Sun--(*^▽^*)","subtitle":"","description":null,"author":"Chen jia","url":"http://jiugework.gitee.io"},"pages":[{"title":"gallery","date":"2019-07-10T14:26:50.234Z","updated":"2019-07-10T14:26:50.234Z","comments":true,"path":"gallery/index.html","permalink":"http://jiugework.gitee.io/gallery/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-30T01:34:03.414Z","updated":"2019-08-30T01:33:51.670Z","comments":true,"path":"about/index.html","permalink":"http://jiugework.gitee.io/about/index.html","excerpt":"","text":"Web前端程序员简历模板（括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6***（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) Github：http://github.com/geekcompany ( 有原创repo的Github帐号会极大的提升你的个人品牌 ) 期望职位：Web前端高级程序员，应用架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU：项目的简要说明，Star和Fork数多的可以注明 WXYZ：项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 javascript css html jquery html5 ajax 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"timeline","date":"2019-07-10T14:03:53.000Z","updated":"2019-07-10T14:15:20.503Z","comments":true,"path":"timeline/index.html","permalink":"http://jiugework.gitee.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"Node函数特点","slug":"node/Node函数","date":"2019-10-05T10:57:42.000Z","updated":"2019-08-25T15:08:51.206Z","comments":true,"path":"2019/10/05/node/Node函数/","link":"","permalink":"http://jiugework.gitee.io/2019/10/05/node/Node函数/","excerpt":"","text":"#模板 Node中任何一个模块(js文件)都被一个外层函数所包裹 function (exports, require, module, filename, dirname) {} exports:用于暴露模块 require:用于引入模块 module:用于暴露模块 filename: 当前文件所在的路径(绝对) dirname: 当前文件所在文件夹的路径(绝对) 为什么要有这个外层函数(这个外层函数有什么作用?) 1,隐藏内部实现。 2.支持CommonJs的模块化T Node函数","categories":[{"name":"Node","slug":"Node","permalink":"http://jiugework.gitee.io/categories/Node/"}],"tags":[]},{"title":"mongoose的增删改查","slug":"node/mongoose的CRUD","date":"2019-08-31T14:32:20.819Z","updated":"2019-08-31T15:46:59.356Z","comments":true,"path":"2019/08/31/node/mongoose的CRUD/","link":"","permalink":"http://jiugework.gitee.io/2019/08/31/node/mongoose的CRUD/","excerpt":"","text":"Create 模型对象.create(文档对象，回调函数) 模型对象.create(文档对象) Read 模型对象.find(查询条件[,投影])不管有没有数据，都返回一个数组 模型对象.findOne(查询条件[,投影])找到了返回一个对象，没找到返回null Update 模型对象.updateOne(查询条件,要更新的内容[,配置对象]) 模型对象.updateMany(查询条件,要更新的内容[,配置对象]) 备注：存在update方法，但是即将废弃，查询条件匹配到多个时，依然只修改一个，强烈建议用updateOne或updateMany Delete 模型对象.deleteOne(查询条件) 模型对象.deleteMany(查询条件) 备注：没有delete方法，会报错！ 备注： 以上所有方法，如果没有指定回调函数，则返回值是一个Promise对象","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://jiugework.gitee.io/categories/MongoDB/"}],"tags":[]},{"title":"GET请求与POST请求","slug":"node/GET请求与POST请求","date":"2019-08-31T14:28:02.677Z","updated":"2019-08-31T15:42:41.047Z","comments":true,"path":"2019/08/31/node/GET请求与POST请求/","link":"","permalink":"http://jiugework.gitee.io/2019/08/31/node/GET请求与POST请求/","excerpt":"","text":"GET请求与POST请求前言 HTTP请求，最初设定了八种方法（也称为“动作”）。这八种方法本质上没有任何区别。只是让请求，更加有语义而已。八种方法分别为：OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT这八种方法最终经过“岁月沉淀”后，常用的只有两种，即：GET和POST GET 含义：从指定的资源获取数据（一种“索取”的感觉）。 什么时候使用GET请求较为合适？ 单纯获取数据的时。 请求中不包含敏感数据时。 POST 含义：向指定的资源提交要被处理的数据（一种“交差”的感觉）。 什么时候使用POST请求较为合适？ 传送相对敏感数据时。 请求的结果有持续性的副作用，例如：传递的数据要作为数据源写入数据库时。备注：使用了POST不代表的绝对的安全。 常见的GET请求： 浏览器地址栏输入网址时（浏览器请求网页时时GET请求，且不可更改） 可以请求外部资源的html标签，例如： 发送Ajax时明确指出了使用GET请求 form表单提交时没有指明方式，默认使用GET 常见的POST请求： 发送Ajax时明确指出了使用POST方式 使用第三方发送Ajax请求库时明确指出用POST时 form表单提交时明确指出使用POST方式 二者的区别","categories":[{"name":"Node","slug":"Node","permalink":"http://jiugework.gitee.io/categories/Node/"}],"tags":[{"name":"GET","slug":"GET","permalink":"http://jiugework.gitee.io/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://jiugework.gitee.io/tags/POST/"}]},{"title":"MongoDB","slug":"node/MongoDB","date":"2019-08-30T01:27:29.214Z","updated":"2019-08-31T15:45:18.355Z","comments":true,"path":"2019/08/30/node/MongoDB/","link":"","permalink":"http://jiugework.gitee.io/2019/08/30/node/MongoDB/","excerpt":"","text":"MongoDB原生CRUD（增删改查）命令总结-C creat： db.集合名.insert(文档对象) db.集合名.insertOne(文档对象) db.集合名.insertMany([文档对象，文档对象]) -R read： db.集合名.find(查询条件[,投影]) 举例:db.students.find({age:18}),查找年龄为18的所有信息 举例:db.students.find({age:18,name:’jack’}),查找年龄为18且名字为jack的学生 常用操作符： &lt; , &lt;= , &gt; , &gt;= , !== 对应为： $lt $lte $gt $gte $ne 举例：db.集合名.find({age:{$gte:20}}),年龄是大于等于20的 逻辑或：使用$in 或 $or 查找年龄为18或20的学生 举例：db.students.find({age:{$in:[18,20]}}) 举例：db.students.find({$or:[{age:18},{age:20}]}) 逻辑非：$nin 正则匹配： 举例：db.students.find({name:/^T/}) $where能写函数： db.students.find({$where:function(){return this.name === &apos;zhangsan&apos; &amp;&amp; this.age === 18 }}) 投影：过滤掉不想要的数据，只保留想要展示的数据 举例：db.students.find({},{_id:0,name:0}),过滤掉id和name 举例：db.students.find({},{age:1}),只保留age 补充：db.集合名.findOne(查询条件[,投影])，默认只要找到一个 -U update： db.集合名.update(查询条件,要更新的内容[,配置对象]) //如下会将更新内容替换掉整个文档对象，但_id不受影响 举例：db.students.update({name:&apos;zhangsan&apos;},{age:19}) //使用$set修改指定内容，其他数据不变，不过只能匹配一个zhangsan 举例：db.students.update({name:&apos;zhangsan&apos;},{$set:{age:19}}) //修改多个文档对象，匹配多个zhangsan,把所有zhangsan的年龄都替换为19 举例：db.students.update({name:&apos;zhangsan&apos;},{$set:{age:19}},{multi:true}) 补充：db.集合名.updateOne(查询条件,要更新的内容[,配置对象]) db.集合名.updateMany(查询条件,要更新的内容[,配置对象]) -D delete db.集合名.remove(查询条件)//删除所有年龄小于等于19的学生 举例：db.students.remove({age:{$lte:19}})","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://jiugework.gitee.io/categories/MongoDB/"}],"tags":[]},{"title":"包管理工具","slug":"node/包管理工具","date":"2019-08-26T02:18:20.716Z","updated":"2019-08-31T15:41:10.800Z","comments":true,"path":"2019/08/26/node/包管理工具/","link":"","permalink":"http://jiugework.gitee.io/2019/08/26/node/包管理工具/","excerpt":"","text":"npm移除 npm remove 包名字 在node_module中删除xxxx包,并且删除该包在package.json中的声助 其他命令 npm aduit fix :检测项目依赖中的一些问题,并且尝试着修复。 npm view 包名字 versions: 查npm仓库中xxx包的所有版本信息 npm view 包名字 version: 查npm仓库中xxxx包的最新版本 npm ls 包名字 查看我们所安装xxx包的版本 关于版本号的说明 &quot;^3.x.x&quot; :锁定大版本以后安装包的时候,保证包是3.对x版本,x默认取最新的。 “~3.1.x”：锁定小版本,以后安装包的时候,保证包是3.1.x版本,x默认取最新的。 “3.1.1”：锁定完整版本,以后安装包的时候,保证包必须是3.1.1版本。 cnpm的简介与使用1.国内使用npm存在的问题 安装npm后，每次我们安装包时，我们的电脑都要和npm服务器进行对话，去npm仓库获取包。 npm默认的仓库地址为：http://registry.npmjs.org 查看当前npm仓库地址命令： npm config get registry 提示如下图： 因为npm的远程服务器在国外，所以有时候难免出现访问过慢，甚至无法访问的情况。为了解决这个问题，我们有以下几个解决办法 2.使用淘宝的cpm代替npm 淘宝为我们搭建了一个国内的npm服务器，它目前是每隔10分钟将国外npm仓库的所有内容“搬运”回国内的服务器上，这样我们直接访问淘宝的国内服务器就可以了，它的地址是：https://registry.npm.taobao.org 使用方法：第一种：直接安装cnpm安装淘宝提供的cnpm，并更改服务器地址为淘宝的国内地址，命令：npm install -g cnpm --registry=https://registry.npm.taobao.org，以后安装直接采用cpm替代npm，例如原生npm命令为：npm install uniq --save，cnpm命令为：cnpm install uniq --save 第二种：替换npm仓库地址为淘宝镜像地址（推荐）命令：npm config set registry https://registry.npm.taobao.org`，查看是否更改成功：npm config get registry，以后安装时，依然用npm命令，但是实际是从淘宝国内服务器下载的 yarn的简介与使用 Yarn发布于2016年10月，截至当前2019年1月，gitHub上的Start数量为：34.3k，已经超过npm很多了，yarn使用本地缓存，无需互联网连接就能安装本地已经缓存的依赖项，安装方法：npm install -g yarn 特别注意：由于yarn的全局安装位置与npm不同，所以要配置yarn的全局安装路径到环境变量中，否则全局安装的包不起作用。具体操作如下： 安装yarn后执行 yarn global dir命令,获取yarn全局安装位置。讲该位置配置到电脑环境变量中 yarn命令与npm命令的对应关系如下：初始化项目:yarn init -y npm init -y 下载项目的所有声明的依赖:yarn npm install 下载指定的运行时依赖包:yarn add webpack@3.2.1 npm install webpack@3.2.1 -S 下载指定的开发时依赖:yarn add webpack@3.2.1 -D npm install webpack@3.2.1 -D 全局下载指定包:yarn global add webpack npm install webpack -g 删除依赖包:yarn remove webpack npm remove webpack -S yarn global remove webpack npm remove webpack -g 运行项目中配置的script:yarn run xxx npm run xxx 查看某个包的信息:yarn info xxx npm info xxx 设置淘宝镜像:yarn config set registry https://registry.npm.taobao.org npm config set registry https://registry.npm.taobao.org","categories":[],"tags":[]},{"title":"模板","slug":"node/模板","date":"2019-08-25T13:55:48.144Z","updated":"2019-08-31T14:37:52.380Z","comments":true,"path":"2019/08/25/node/模板/","link":"","permalink":"http://jiugework.gitee.io/2019/08/25/node/模板/","excerpt":"","text":"","categories":[{"name":"Node","slug":"Node","permalink":"http://jiugework.gitee.io/categories/Node/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"","slug":"work/周报","date":"2019-08-09T06:16:23.370Z","updated":"2019-08-30T07:36:24.302Z","comments":true,"path":"2019/08/09/work/周报/","link":"","permalink":"http://jiugework.gitee.io/2019/08/09/work/周报/","excerpt":"","text":"周报2019-08-19—-2019-08-23教师端 性别选择问题渲染 校区选择,判断一个校区时候直接进入。 配置修改小程序后台配置老师帮appid,上传到体验版 修改课程详情接口教务端 个人中心资料页面，资料修改头像上传 校区切换 获取消息 首页页面修改 2019年8月26教务端 课程详情页面。获取详情内容 课堂播报tab静态页面，课堂播报接口。 课堂播报详情、点赞、评论功能。 课程打卡状态处理，打卡页面重写，打卡详情重写。 打卡详情接口、学生选择列表静态","categories":[],"tags":[]},{"title":"Class类","slug":"js/Class","date":"2019-07-28T01:26:53.000Z","updated":"2019-07-28T01:29:38.951Z","comments":true,"path":"2019/07/28/js/Class/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/Class/","excerpt":"","text":"类的本质 class本质还是function 类的所有方法都定义在类的prototype属性上 类创建的实例,里面也有proto-指向类的prototype原型对象 所以ES6的类它的绝大部分功能, ES5都可以做到,新的class写法只是让对象原型的写法更加清晰、更像面向对编程的语法而已。 所以ES6的类其实就是语法糖. 语法糖语法糖就是一种便捷写法.简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便那么这个方法就是语法糖","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Class","slug":"Class","permalink":"http://jiugework.gitee.io/tags/Class/"}]},{"title":"面向对象","slug":"js/面向对象","date":"2019-07-28T01:26:53.000Z","updated":"2019-08-06T08:59:10.254Z","comments":true,"path":"2019/07/28/js/面向对象/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/面向对象/","excerpt":"","text":"创建对象的三中方式 利用new object()创建对象 1var obj1=new Object(); 利用 对象字面量创建对象 1var obj1=&#123;&#125; 通过构造函数创建对象 12345678function Star(name,sex)&#123; this.name = name; this.sex=sex; this.sing=function()&#123; console.log(\"唱歌\") &#125;&#125;var zxy= new Star('张学友','男');//实例化 new在执行会做四件事 在内存创建一个空对象 让this指向这个对象 执行构造函数里面的代码，给这个新对象添加属性以及方法 返回这个新对象 ） 实例成员和静态成员 实例成员就是构造函数内部通过this添加的成员，```sex``` sing12345- **实例成员**只能通过实例化的对象来访问```javascript console.log(zxy.name) 静态成员 在构造函数本身上添加的的成员就是静态成员 例如 1Star.age=18 静态成员只能通过构造函数来访问 12console.log(Star.sex)//能访问console.log(zxy.sex)//不能访问 prototype构造函数原型 构造函数通过原型分配的函数是所有对象所共享的。JavaScript规定,每一个构造函数都有一个prototype属性,指向另一个对象。注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。 123456789101112131415 function Star(name,sex)&#123; this.name = name; this.sex=sex; // this.sing=function()&#123; // console.log(\"唱歌\") //&#125; &#125;Star.prototype.sing=function()&#123; console.log(\"唱歌\") &#125; var zxy= new Star('张学友','男'); var cj= new Star('cj','男');zxy.sing===cj.sing //truezxy.sing() //唱歌 原型是什么? 一个对象,我们也称为prototype为原型对象 原型的作用是什么? 共享方法。 一般情况下,我们的公共属性定义到构造函数里面,公共的方法我们放到原型对象身上 对象原型proto对象都会有一个属性_proto_指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数 prototype原型对象的属性和方法,就是因为对象有proto原型的存在。 proto对象原型和 原型对象prototype是等价的* 1console.log(cj.__proto__===Star.prototype);//true 方法的查找规则: 首先先看ldh对象身上是否有sing方法,如果有就执行这个对象上的sing 如果么有sing这个方法,因为有一proto的存在,就去构造函数原型对象prototype身上去查找 sing这个方法 constructor构造函数对象原型(proto )和构造函数( prototype)原型对象里面都有一个属性constructor属性, constructor我们称为构造函数，因为它指回构造函数本身。 作用 constructor主要用于记录该对象引用于哪个构造函数,它可以让原型对象重新指向原来的构造函数 1234console.log(Star.prototype);console.log(ldh.proto_);console.log(star.prototype.constructor);console.log(ldh. proto_.constructor); 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor 123456789star.prototype =&#123; constructor: star , sing: function()&#123; console. log(' 我 歌');&#125;, movie: function() &#123; console.1og('我会演电影); &#125; &#125; 原型链JavaScript的成员查找机制(规则) 当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性。 如果没有就查找它的原型(也就是proto指向的prototype原型对象)。 如果还没有就查找原型对象的原型(Object的原型对象)。 依此类推一直找到Object为止(null )。 proto对象原型的意义就在于为对象成员查找机制提供一个方向,或者说一条路线。 给Array添加自定义方法12345Array.prototype.xx=()=&gt;&#123; console.log(\"xxxxxx\"); &#125; list.xx();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://jiugework.gitee.io/tags/面向对象/"}]},{"title":"Call","slug":"js/Call","date":"2019-07-28T01:26:53.000Z","updated":"2019-07-28T01:28:50.385Z","comments":true,"path":"2019/07/28/js/Call/","link":"","permalink":"http://jiugework.gitee.io/2019/07/28/js/Call/","excerpt":"","text":"Call用法 调用函数 123456function dr() &#123; console.log(\"play\"); console.log(this); //window &#125; dr.call() //play Call可以改变函数this的指向 12345678function dr() &#123; console.log(\"play\"); console.log(this); //指向o &#125; let o=&#123; name:'哈哈哈' &#125; dr.call(o) 此时这个函数的this就指向了o这个对象 123456789101112 function dr(x,y) &#123; console.log(\"play\"); console.log(this); //指向o console.log(x+y); &#125; let o=&#123; name:'哈哈哈' &#125; dr.call(o,1,2)// play// &#123;name: \"哈哈哈\"&#125;// 3 继承 继承属性 1234567891011121314//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex //把子的this传入到父 // this指向实例对象 Father.call(this, name, age) &#125;; let zs = new Son(\"张三\", 18, 'nan') console.log(zs); 继承方法 1Son. prototype = Father.prototype; //这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 12345678910111213141516171819202122232425//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; Father.prototype.money=function()&#123; console.log(\"钱\")&#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex Father.call(this, name, age) &#125;; Son.prototype=new Father(); //如果利用对象的形式修改来原型对象，别忘了利用 constructor指回原来的对象 Son.prototype.constructor=Son Son.prototype.play=function()&#123; console.log(\"吃饭\"); &#125; let zs = new Son(\"张三\", 18, 'nan'); zs.money(); zs.play(); console.log(zs); console.log(Father);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Call","slug":"Call","permalink":"http://jiugework.gitee.io/tags/Call/"}]},{"title":"Vue样式绑定方式","slug":"Vue/样式","date":"2019-07-22T12:33:15.236Z","updated":"2019-07-29T14:25:25.865Z","comments":true,"path":"2019/07/22/Vue/样式/","link":"","permalink":"http://jiugework.gitee.io/2019/07/22/Vue/样式/","excerpt":"","text":"第一种方式 直接传递一个数组 这里的class需要用v-bind绑定 12345678910111213141516171819&lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active&#123; letter-spacing: 0.5em; &#125; &lt;/style&gt; &lt;div id=\"app\"&gt;&lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; 第二种方式 通过三元表达式 12345678910111213141516171819 &lt;div id=\"app\"&gt;&lt;!-- &lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;1 --&gt;&lt;h1 :class=\"['red','active',flag?'thin':'']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; flag:true &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 第三种方式 把样式放到对象里把key为样式名，把value值绑定到一个bool值上 1&lt;h1 :class=\"['red','active',&#123;'thin':flag&#125;]\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; 第四种方式 传入一个对象本质跟第三种方法差不多 1&lt;h1 :class=\"&#123;red:flag,active:true,active:true&#125;\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; 或 123456789101112131415161718192021 &lt;div id=\"app\"&gt;&lt;!-- &lt;h1 :class=\"['red','active']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;1 --&gt;&lt;!-- &lt;h1 :class=\"['red','active',flag?'thin':'']\"&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt;2 --&gt;&lt;h1 :class='classObj'&gt;这是一个很大很大的H1，打到你无法想象&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; flag:true, classObj:&#123;red:true,active:true,active:true&#125; &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 内联样式 直接在元素123```html&lt;h1 :style=&quot;&#123;color:&apos;red&apos;,&apos;font-weight&apos;:200 &#125;&quot;&gt;变色&lt;/h1&gt; 在data中引用到:style 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=\"app\"&gt;&lt;h1 :style=\"styleObj1\"&gt;变色&lt;/h1&gt;&lt;!-- &lt;h1 :style=\"&#123;color:'red','font-weight':200 &#125;\"&gt;变色&lt;/h1&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; let vm = new Vue(&#123; el:'#app', data:&#123; styleObj1:&#123; color:'red','font-weight':200 &#125; &#125;, methods: &#123; &#125;, &#125;)&lt;/script&gt; 第三种绑定一个数组 123456789&lt;h1 :style=\"[ styleObj1,styleObj2 ]\"&gt;变色&lt;/h1&gt; data:&#123; styleObj1:&#123; color:'red','font-weight':200 &#125;, styleObj2:&#123; 'font-size':'60px' &#125; &#125;,","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"Vue样式","slug":"Vue样式","permalink":"http://jiugework.gitee.io/tags/Vue样式/"}]},{"title":"Vue指令","slug":"Vue/Vue指令","date":"2019-07-21T15:09:49.263Z","updated":"2019-07-22T13:54:16.015Z","comments":true,"path":"2019/07/21/Vue/Vue指令/","link":"","permalink":"http://jiugework.gitee.io/2019/07/21/Vue/Vue指令/","excerpt":"","text":"v-cloak 可以解决插值表达式闪烁问题 V-for 组件中使用v-for需要绑定key in后面可以放 数组，对象数组，对象，数字 循环普通数组 1&lt;h1 v-for=&quot;(item,i) in list &quot;&gt;&#123;&#123;item&#125;&#125;&lt;/h1&gt; 迭代数字 1&lt;h1 v-for=&quot;count in 10&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; v-html 可以渲染出带有标签的文本 v-if跟v-show show控制显示隐藏需要频繁切换建议使用 if控制是否渲染页面是否存在这个节点 v-text 可以解决插值表达式闪烁问题 v-bind 缩写 是“:” Vue的属性绑定机制 v-bind只能实现数据的单项绑定，只能从M绑定到V，无法实现数据的双向绑定 v-on Vue提供的事件绑定机制 缩写是“@” v-model 只能在表单元素中使用 实现双向数据绑定 使用v-model可以实现表单元素和model中数据的双向数据绑定 12&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;input type=\"text\" v-model:value=\"msg\" &gt; ​ 或者 1&lt;input type=\"text\" v-model=\"msg\" &gt; 案例 正式开发中尽量少用eval() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"n1\"&gt; &lt;select v-model=\"opt\"&gt; &lt;option v-for=\"item in list\" :key=\"item.index\"&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" v-model=\"n2\" bu&gt; = &lt;input type=\"text\" v-model=\"result\" @focus=\"comp\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; n1: '', n2: '', opt: '-', result: '', list: ['+', '-', '*', '/'] &#125;, methods: &#123; comp() &#123; let result=this.n1+this.opt+this.n2 this.result= eval(result) // switch (this.opt) &#123; // case '+': // this.result = Number(this.n1) + Number(this.n2) // break; // case '-': // this.result = Number(this.n1) - Number(this.n2) // break; // case '/': // this.result = Number(this.n1) / Number(this.n2) // break; // case '*': // this.result = Number(this.n1) * Number(this.n2) // break; // default: // break; // &#125; &#125; &#125;, &#125;)&lt;/script&gt; 事件修饰符 .stop阻止冒泡（ 里–》外） .prevent阻止默认事件（） .capture添加事件监听器时使用事件捕获模式（外–&gt;里） .self只当事件在该元素（比如不是子元素）触发是触发回调(自己触发自己，) 只会阻止自己冒泡，并不会阻止其他的冒泡 .once事件只触发一次","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"指令","slug":"指令","permalink":"http://jiugework.gitee.io/tags/指令/"}]},{"title":"数组中常用的方法","slug":"js/数组","date":"2019-07-19T13:15:26.048Z","updated":"2019-08-31T15:48:13.354Z","comments":true,"path":"2019/07/19/js/数组/","link":"","permalink":"http://jiugework.gitee.io/2019/07/19/js/数组/","excerpt":"","text":"开发中数组的使用场景非常多, 这里就简单整理总结一些常用的方法;从改变原有数据的方法、不改变原有数组的方法以及数据遍历的方法三方面总结。 改变原有数组的方法splice() 添加/删除数组元素 1234567let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]// 从0开始截取到第三个位置console.log(a); // [4,5,6,7]let item1 = a.splice(0,3,'添加'); // [4,5,6]console.log(a); // ['添加',7]// 从数组下标0开始，删除3个元素，并添加元素'添加' sort() 数组排序1234567891011var array = [10, 1, 3, 4,20,4,25,8]; // 升序 a-b &lt; 0 a将排到b的前面，按照a的大小来排序的 array.sort(function(a,b)&#123; return a-b; &#125;); console.log(array); // [1,3,4,4,8,10,20,25]; // 降序 array.sort(function(a,b)&#123; return b-a; &#125;); console.log(array); // [25,20,10,8,4,4,3,1]; pop() 删除一个数组中的最后的一个元素 shift() 删除数组的第一个元素 push() 向数组的末尾添加元素 unshift()向数组开头添加元素 reverse()1234567891011let a = [1,2,3]; a.pop(); // 3, 返回被删除的元素 console.log(a); // [1,2] a.shift(); // 1 console.log(a); // [2] a.push(\"末尾添加\"); // 2 ,返回数组长度 console.log(a) ; [2,\"末尾添加\"] a.unshift(\"开头添加\"); // 3 console.log(a); //[\"开头添加\", 2, \"末尾添加\"] a.reverse(); // [\"末尾添加\", 2, \"开头添加\"] console.log(a) // [\"末尾添加\", 2, \"开头添加\"] copyWithin() 指定位置的成员复制到其他位置1234let a = ['zhang', 'wang', 'zhou', 'wu', 'zheng']; // 1位置开始被替换, 2位置开始读取要替换的 5位置前面停止替换 a.copyWithin(1, 2, 5); // [\"zhang\", \"zhou\", \"wu\", \"zheng\", \"zheng\"] ES6: fill() 填充数组1234['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 以上是9种会改变原数组的方法, 接下来是6种常用的不会改变原数组的方法 不改变原数组的方法join() 数组转字符串12let a= ['hello','world']; let str2=a.join('+'); // 'hello+world' cancat 合并两个或多个数组1234let a = [1, 2, 3]; let b = [4, 5, 6]; //连接两个数组 let newVal=a.concat(b); // [1,2,3,4,5,6] ES6扩展运算符…合并数组1234let a = [2, 3, 4, 5] let b = [ 4,...a, 4, 4] console.log(a,b); //[2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标123let a=['啦啦',2,4,24,NaN]console.log(a.indexOf('啦')); // -1console.log(a.indexOf('啦啦')); // 0 ES7 includes() 查找数组是否包含某个元素 返回布尔 indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观1234let a=['OB','Koro1',1,NaN]; a.includes(NaN); // true 识别NaN a.includes('Koro1',100); // false 超过数组长度 不搜索 a.includes('Koro1',-3); // true 从倒数第三个元素开始搜索 slice() 浅拷贝数组的元素 字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。1234567let a = [&#123;name: 'OBKoro1'&#125;, &#123;name: 'zhangsan'&#125;]; let b = a.slice(0,1); console.log(b, a); // [&#123;\"name\":\"OBKoro1\"&#125;] [&#123;\"name\":\"OBKoro1\"&#125;] a[0].name='改变原数组'; console.log(b,a); // [&#123;\"name\":\"改变原数组\"&#125;] [&#123;\"name\":\"改变原数组\"&#125;]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://jiugework.gitee.io/tags/数组/"},{"name":"Array","slug":"Array","permalink":"http://jiugework.gitee.io/tags/Array/"}]},{"title":"常用CSS样式","slug":"css/css1","date":"2019-07-16T09:21:34.109Z","updated":"2019-08-31T15:48:02.219Z","comments":true,"path":"2019/07/16/css/css1/","link":"","permalink":"http://jiugework.gitee.io/2019/07/16/css/css1/","excerpt":"","text":"CSS超出部分显示省略号12345678910111213141516171819202122232425/* 单行 */.overflow&#123; overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125;/* 多行 */.more_overflow&#123;display: -webkit-box;text-overflow: ellipsis;-webkit-box-orient: vertical;-webkit-line-clamp: 2; /* 显示行数 */overflow: hidden;&#125;## css元素垂直居中```css.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; banner自适应屏幕代码123456789101112div &#123; width:100%; position:relative; overflow:hidden; height:200px;&#125;img &#123; width:3000px;/*图片宽度*/ position:absolute; left:50%; margin-left:-1500px;/*图片宽度的一半*/ &#125; `","categories":[{"name":"Css","slug":"Css","permalink":"http://jiugework.gitee.io/categories/Css/"}],"tags":[{"name":"常用CSS","slug":"常用CSS","permalink":"http://jiugework.gitee.io/tags/常用CSS/"}]},{"title":"字符串常用操作","slug":"js/字符串常用操作","date":"2019-07-11T09:02:07.077Z","updated":"2019-08-31T15:51:58.487Z","comments":true,"path":"2019/07/11/js/字符串常用操作/","link":"","permalink":"http://jiugework.gitee.io/2019/07/11/js/字符串常用操作/","excerpt":"","text":"判断开头结尾 startsWidth判断以什么开头 endsWidth判断以什么结尾 1let str='https://www.4399.com'; // alert(str.startsWith('a')) //判断是否以'a'开头，返回bool值 endsWidth同理 判断包含 includes判断是够包含某个字符串 返回bool值 indexOf判断是否包含并且返回下标，不存在返回-1 1234567let str = '123456';str.includes('456') //truestr.includes('46') //falsestr.indexOf(\"1\") //0 //存在str.indexOf(\"45\") //3 //存在str.indexOf(\"46\") //-1 //不存在 字符串截取 slice substring substr 12345678910111213141516let str = 'abcdef';str = str.slice(0);//返回整个字符串 abcdefstr = str.substring(0);//返回整个字符串 abcdefstr = str.substr(0);//返回整个字符串 abcdef// 使用一个参数str = str.slice(2);//截取第二个之后所有的字符 cdefstr = str.substring(2);//截取第二个之后所有的字符 cdefstr = str.substr(2);//截取第二个之后所有的字符 cdef// 使用两个参数str = str.slice(2,4);//截取第二个到第四个之间的字符 cdstr = str.substring(2,4);//截取第二个到第四个之间的字符 cd 前下标str = str.substr(2,4);//截取从第3个开始往后数4位之间的字符 cdef// 使用两个负数str = str.slice(1,-3);//截取第二个到倒数第三个str = str.substr(1,-3);//不能为负数，若强行传递负数，会被当成0处理 ' ' #负数转换为0 字符串和数组相互转换 split join 123456789// 字符串转数组let str = \"abc,abcd,aaa\";t = str.split(\",\");// 在每个逗号(,)处进行分解 [\"abc\", \"abcd\", \"aaa\"]var str = \"helloworld\";t1 = str.split(''); //[\"h\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\"]// 数组转字符串var a, b;a = new Array(0,1,2,3,4);b = a.join(\"-\"); //\"0-1-2-3-4\"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"String","slug":"String","permalink":"http://jiugework.gitee.io/tags/String/"},{"name":"字符串","slug":"字符串","permalink":"http://jiugework.gitee.io/tags/字符串/"}]},{"title":"Vue组件","slug":"Vue/组件","date":"2019-07-08T10:57:42.000Z","updated":"2019-07-31T14:36:57.302Z","comments":true,"path":"2019/07/08/Vue/组件/","link":"","permalink":"http://jiugework.gitee.io/2019/07/08/Vue/组件/","excerpt":"","text":"定义vue组件什么是组件:组件的出现,就是为了拆分Vue实例的代码量的,能够让我们以不同的组件,来划分不同的功能模块,将来我们需要什么样的功能,就可以去调用对应的组件即可组件化和模块化的不同: 模块化:是从代码逻辑的角度进行划分的;方便代码分层开发,保证每个功能模块的职能单一 组件化:是从U1界面的角度进行组件的重用 全局 方式1： 1234567891011121314151617&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 驼峰通过 - 来连接--&gt; &lt;my-comm&gt;&lt;/my-comm&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('myComm', &#123; template:`&lt;div&gt;这是一个组件&lt;/div&gt;` //一定要写个html标签包裹 &#125;) let vm = new Vue(&#123; ... &#125;)&lt;/script&gt; 方式2： 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;mycomm1&gt;&lt;/mycomm1&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;外部组件&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; Vue.component('mycomm1', &#123; template:'#tmp1' &#125;) let vm = new Vue(&#123;... &#125;)&lt;/script&gt; 私有 12345components:&#123; login:&#123; template:&apos;&lt;h1&gt;私有的&lt;/h1&gt;&apos; &#125; &#125; 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;私有&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; &#125;, components:&#123; login:&#123; template:'#tmp1' &#125; &#125; &#125;)&lt;/script&gt; 组件中的methods与data 组件可以有自己的data数据 组件的data和实例的data有点不一样,实例中的data可以为一个对象,但是组件中的data必须是一个方法 组件中的data除了必须为一个方法之外,这个方法内部,还必须返回一个对象才行跟data一样 1234&lt;div id=\"app\"&gt; &lt;!-- &lt;my-comm &gt;&lt;/my-comm&gt; --&gt; &lt;mycomm1&gt;&lt;/mycomm1&gt; &lt;/div&gt; 12345678Vue.component('myComm', &#123; template: `&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; msg: 'ddd' &#125; &#125; &#125;) method 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=\"app\"&gt; &lt;my-comm&gt;&lt;/my-comm&gt; &lt;hr&gt; &lt;my-comm&gt;&lt;/my-comm&gt; &lt;hr&gt; &lt;my-comm&gt;&lt;/my-comm&gt; &lt;hr&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;外部组件:&#123;&#123;num&#125;&#125;&lt;/h1&gt; &lt;button @click=\"add\"&gt;点击加1&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; let obj=&#123; num: 0 &#125; Vue.component('myComm', &#123; template: '#tmp1', data: function () &#123; // return obj return &#123; num: 0 &#125; &#125;, methods: &#123; add()&#123; this.num++ &#125; &#125;, &#125;) let vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hahah ' &#125;, &#125;)&lt;/script 组件切换1234567891011121314151617181920212223242526272829303132333435 &lt;div id=\"app\"&gt; &lt;button @click=\"temp='my-comm1'\"&gt;登陆&lt;/button&gt; &lt;button @click=\"temp='my-comm2'\"&gt;注册&lt;/button&gt; &lt;transition enter-active-class=\"animated zoomIn\" leave-active-class=\"animated zoomOut\" :duration=\"&#123; enter:200,leave:500 &#125;\"&gt; &lt;component :is=\"temp\"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;h1&gt;登陆&lt;/h1&gt; &lt;/template&gt; &lt;template id=\"tmp2\"&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; Vue.component('myComm1', &#123; template: '#tmp1', &#125;) Vue.component('myComm2', &#123; template: '#tmp2', &#125;) let vm = new Vue(&#123; el: '#app', data: &#123; msg: 'hahah ', temp:'my-comm1' &#125;, &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://jiugework.gitee.io/tags/组件化/"},{"name":"Vue组件","slug":"Vue组件","permalink":"http://jiugework.gitee.io/tags/Vue组件/"}]},{"title":"模板","slug":"js/1bbbbb","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-28T01:46:26.346Z","comments":true,"path":"2019/07/05/js/1bbbbb/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/js/1bbbbb/","excerpt":"","text":"#模板","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"模板","slug":"Vue/模板","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-16T07:40:02.787Z","comments":true,"path":"2019/07/05/Vue/模板/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/模板/","excerpt":"","text":"#模板","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[]},{"title":"Cli","slug":"Vue/cli","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-04T03:05:02.160Z","comments":true,"path":"2019/07/05/Vue/cli/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/cli/","excerpt":"","text":"安装1npm install -g @vue/cli 创建项目 123vue create my-project# ORvue ui","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"Cli","slug":"Cli","permalink":"http://jiugework.gitee.io/tags/Cli/"}]},{"title":"判断JS数据类型的四种方法","slug":"js/判断JS数据类型的四种方法","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-30T06:45:16.180Z","comments":true,"path":"2019/07/05/js/判断JS数据类型的四种方法/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/js/判断JS数据类型的四种方法/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://jiugework.gitee.io/tags/数据类型/"},{"name":"判断数据类型","slug":"判断数据类型","permalink":"http://jiugework.gitee.io/tags/判断数据类型/"},{"name":"检测类型","slug":"检测类型","permalink":"http://jiugework.gitee.io/tags/检测类型/"}]},{"title":"自定义指令","slug":"Vue/自定义指令","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-30T14:00:10.646Z","comments":true,"path":"2019/07/05/Vue/自定义指令/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/自定义指令/","excerpt":"","text":"自定义指令 使用vue.dizective ()定义全局的指令 v-focus 参数1 :指令的名称,注意,在定义的时候,指令的名称前面,不需要加v-前缀 但是:在调用的时候,必须在指令名称前加上v-前缀来进行调用 参数2:是一个对象,这个对象身上,有一些指令相关的函数,这些函数可以在特定的阶段,执行相关的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-focus v-color=\"blue\" v-bold v-fz=\"30\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.directive('focus', &#123; inserted(el) &#123; el.focus(); &#125;, updated() &#123; &#125;, &#125;); Vue.directive('color', &#123; bind(el, binding) &#123; console.log(binding); console.log(el.style.color = binding.value); &#125;, inserted(el) &#123;//操作 el.focus(); &#125;, updated() &#123; &#125;, &#125;); let vm = new Vue(&#123; el: '#app', data: &#123; blue: 'blue' &#125;, directives: &#123; 'bold': &#123; bind(el, binding) &#123; console.log(binding, '私有的'); console.log(el.style.fontWeight = \"bold\"); &#125;, &#125;, 'fz':(el,binding)=&gt;&#123; //等同于把代码写到了 bind和update里面去el.style.fontSize=parseInt(binding.value)+'px'; &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"指令","slug":"指令","permalink":"http://jiugework.gitee.io/tags/指令/"},{"name":"自定义","slug":"自定义","permalink":"http://jiugework.gitee.io/tags/自定义/"}]},{"title":"ref传值与获取Dom","slug":"Vue/ref","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-03T03:09:43.904Z","comments":true,"path":"2019/07/05/Vue/ref/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/ref/","excerpt":"","text":"ref寻找dom元素1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\"&gt;&lt;button @click=\"getElement\" ref=\"zz\" &gt;获取元素&lt;/button&gt;&lt;button @click=\"getElement\" ref=\"zz1\" &gt;获取元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; &#125;, created()&#123; &#125;, methods: &#123; getElement()&#123; console.log(this.$refs.zz.innerText); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 利用ref获取子组件方法以及数据12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id=\"app\"&gt;&lt;button @click=\"getElement\" ref=\"zz\" &gt;获取子组件方法和data&lt;/button&gt;&lt;login ref=\"son\" &gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; let login = &#123; data() &#123; return &#123; msg:'x么恶魔' &#125; &#125;, methods: &#123; show()&#123; console.log(\"调用了\") &#125; &#125;, template:'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;' &#125; let vm = new Vue(&#123; el: '#app', data: &#123; dd:'我是父组件的值' &#125;, created()&#123; &#125;, methods: &#123; getElement()&#123; // console.log(this.$refs.zz.innerText); console.log(this.$refs.son.msg=this.dd);//修改值 this.$refs.son.show(); &#125; &#125;, components:&#123; login &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"ref","slug":"ref","permalink":"http://jiugework.gitee.io/tags/ref/"},{"name":"组件通讯","slug":"组件通讯","permalink":"http://jiugework.gitee.io/tags/组件通讯/"},{"name":"子组件","slug":"子组件","permalink":"http://jiugework.gitee.io/tags/子组件/"}]},{"title":"Vue-Router","slug":"Vue/路由","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-03T07:38:59.428Z","comments":true,"path":"2019/07/05/Vue/路由/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/路由/","excerpt":"","text":"路由 后端路由:对于普通的网站,所有的超链接都是URL地址,所有的URL地址都对应服务器上对应的资源; 前端路由:对于单页面应用程序来说,主要通过URL中的hash(#号)来实现不同页面之间的切换,同时, hash有一个特点: HTTP请求中不会包含hash相关的内容;所以,单页面程序中的页面跳转主要用hash实现 在单页面应用程序中,这种通过hash改变来切换页面的方式,称作前端路由(区别于后端路由) ; 基本使用 组件一定要在路由之前。不然页面会没有东西 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot; &gt;登陆&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;div&gt;登陆组件&lt;/div&gt;&apos; &#125; var register = &#123; template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos; &#125; let routerObj= new VueRouter(&#123; routes:[ &#123; path:&apos;/login&apos;,component:login, &#125;, &#123; path:&apos;/register&apos;,component:register, &#125;, ] &#125;) let vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; &#125;, router:routerObj, &#125;) &lt;/script&gt;&lt;/body&gt; 重定向1&#123;path:'/',redirect:'/login'&#125;, 路由选中样式12345678router-link-active //默认//自定义let routerObj = new VueRouter(&#123; routes: [ ... ], linkActiveClass: 'myC' &#125;) 路由定义参数方式1 通过$route.query能拿到路由参数 具体的是在query里面 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/login?id='10'\"&gt;登陆&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;div&gt;登陆组件&#123;&#123;$route.query.id&#125;&#125;&lt;/div&gt;', created() &#123; console.log(this.$route.query.id); &#125;, &#125; var register = &#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125; let routerObj = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login, &#125;, &#123; path: '/register', component: register, &#125;, ], &#125;) let vm = new Vue(&#123; el: '#app', router: routerObj, &#125;) &lt;/script&gt;&lt;/body&gt; 方式2 通过$route.query能拿到路由参数 具体的在params对象里面 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/login/12\"&gt;登陆&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;div&gt;登陆组件&lt;/div&gt;', created() &#123; console.log(this.$route.params.id); &#125;, &#125; var register = &#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125; let routerObj = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login/:id', component: login, &#125;, &#123; path: '/register', component: register, &#125;, ], &#125;) let vm = new Vue(&#123; el: '#app', router: routerObj, &#125;) &lt;/script&gt;&lt;/body&gt; 路由嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=\"home\"&gt; &lt;div&gt; &lt;router-link to=\"/home/login/12\"&gt;登陆&lt;/router-link&gt; &lt;router-link to=\"/home/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var home = &#123; template: '#home' &#125; var login = &#123; template: '&lt;div&gt;登陆组件&lt;/div&gt;', created() &#123; console.log(this.$route.params.id); &#125;, &#125; var register = &#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125; let routerObj = new VueRouter(&#123; routes: [ &#123; path: '/home', component: home, children: [ &#123; path: 'login/:id', component: login, &#125;, &#123; path: 'register', component: register, &#125;, ] &#125;, ], &#125;) let vm = new Vue(&#123; el: '#app', router: routerObj, &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"Router","slug":"Router","permalink":"http://jiugework.gitee.io/tags/Router/"}]},{"title":"模板","slug":"Webpack/模板 - 副本","date":"2019-07-05T10:57:42.000Z","updated":"2019-07-28T01:46:26.346Z","comments":true,"path":"2019/07/05/Webpack/模板 - 副本/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Webpack/模板 - 副本/","excerpt":"","text":"#模板","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"移动端适配Rem","slug":"移动端/REM","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-26T01:59:34.467Z","comments":true,"path":"2019/07/05/移动端/REM/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/移动端/REM/","excerpt":"","text":"移动端适配12345678910111213141516171819202122232425var pageFontSize;var clientWidth;(function(doc, win) &#123; var docEl = doc.documentElement, // 手机旋转事件,大部分手机浏览器都支持 onorientationchange 如果不支持，可以使用原始的 resize resizeEvt = \"orientationchange\" in window ? \"orientationchange\" : \"resize\"; recalc = function() &#123; //clientWidth: 获取对象可见内容的宽度，不包括滚动条，不包括边框 clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt; 1440) &#123; pageFontSize = 100 * (clientWidth / 1920); &#125; else if (clientWidth &gt; 750) &#123; pageFontSize = 100 * (clientWidth / 1440); &#125; else &#123; pageFontSize = 100 * (clientWidth / 750); &#125; docEl.style.fontSize = pageFontSize + \"px\"; &#125;; recalc(); //判断是否支持监听事件 ，不支持则停止 if (!doc.addEventListener) return; //注册翻转事件 win.addEventListener(resizeEvt, recalc, false);&#125;)(document, window);","categories":[],"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"http://jiugework.gitee.io/tags/移动端适配/"}]},{"title":"监听","slug":"Vue/监听","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-03T14:04:26.532Z","comments":true,"path":"2019/07/05/Vue/监听/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/监听/","excerpt":"","text":"监听文本框数据改变通过@keyup监听键盘 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;one&quot; @keyup=&quot;getAll&quot;&gt; &lt;input v-model=&quot;two&quot; @keyup=&quot;getAll&quot;&gt; &lt;input v-model=&quot;all&quot;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; one: &apos;&apos;, two: &apos;&apos;, all: &apos;&apos;, &#125;, methods: &#123; getAll() &#123; this.all = this.one + &apos;-&apos; + this.two &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; Watch123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input v-model=\"one\"&gt; &lt;input v-model=\"two\" &gt; &lt;input v-model=\"all\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; one: '', two: '', all: '', &#125;, watch: &#123; one: function (newVal,oldVal) &#123; console.log(oldVal); this.all = newVal + '-' + this.two &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 监视路由 12345watch: &#123; '$route.path': function (newVal, oldVal) &#123; console.log(newVal + '------' + oldVal); &#125; &#125;, computed计算属性 计算属性,在引用的时候,一定不要加()去调用,直接把它当作普通属性去使用就好了; 只要计算属性,这个function内部,所用到的任何data中的数据发送了变化,就会立即重新计算这个计算属性的值 计算属性的求值结果,会被缓存起来,方便下次直接使用;如果计算属性方法中,所以来的任何数据,都没有发生过变化,则,不会重新对计算属性求值 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input v-model=\"one\"&gt; &lt;input v-model=\"two\" &gt; &lt;input v-model=\"all\"&gt; &lt;input v-model=\"me\"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; one: '', two: '', me:'' &#125;, computed: &#123; all: function()&#123; console.log(this.me); return this.one+'-'+this.two &#125;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 对比 computed属性的结果会被缓存,除非依赖的响应式属性变化才会重新计算。主要当作属性来使用; methods方法表示一个具体的操,,主要书写业务逻辑; watch一个对象,键是需要观察的表达式,值是对应回调函数。主要用来监听某些特定数据的变化,从而进行某些具体的业务逻辑操作;可以看作是computed和methods的结合体;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"监听","slug":"监听","permalink":"http://jiugework.gitee.io/tags/监听/"},{"name":"watch","slug":"watch","permalink":"http://jiugework.gitee.io/tags/watch/"}]},{"title":"webpack","slug":"Webpack/模板","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-03T14:05:20.046Z","comments":true,"path":"2019/07/05/Webpack/模板/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Webpack/模板/","excerpt":"","text":"#模板","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://jiugework.gitee.io/tags/webpack/"}]},{"title":"Node.js","slug":"node/Node.js介绍","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-25T14:54:22.482Z","comments":true,"path":"2019/07/05/node/Node.js介绍/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/node/Node.js介绍/","excerpt":"","text":"Node.js有什么特点优点 异步非阻塞的I/O (I/O线程池) （文件/数据库）的读写 特别适用于I/O密集型应用 事件循环机制 单线程 - 一个人多干活 跨平台 缺点 回调函数嵌套太多、太深(俗称回调地狱) 单线程,处理不好CPU密集型任务 应用场景 Web服务API 服务器渲染页面,提升速度 后端的Web服务,例如跨域、服务器端的请求。","categories":[{"name":"Node","slug":"Node","permalink":"http://jiugework.gitee.io/categories/Node/"}],"tags":[{"name":"Node特点","slug":"Node特点","permalink":"http://jiugework.gitee.io/tags/Node特点/"}]},{"title":"移动端适配Rem","slug":"移动端/模板 ","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-26T01:59:54.403Z","comments":true,"path":"2019/07/05/移动端/模板 /","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/移动端/模板 /","excerpt":"","text":"移动端适配12345678910111213141516171819202122232425var pageFontSize;var clientWidth;(function(doc, win) &#123; var docEl = doc.documentElement, // 手机旋转事件,大部分手机浏览器都支持 onorientationchange 如果不支持，可以使用原始的 resize resizeEvt = \"orientationchange\" in window ? \"orientationchange\" : \"resize\"; recalc = function() &#123; //clientWidth: 获取对象可见内容的宽度，不包括滚动条，不包括边框 clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt; 1440) &#123; pageFontSize = 100 * (clientWidth / 1920); &#125; else if (clientWidth &gt; 750) &#123; pageFontSize = 100 * (clientWidth / 1440); &#125; else &#123; pageFontSize = 100 * (clientWidth / 750); &#125; docEl.style.fontSize = pageFontSize + \"px\"; &#125;; recalc(); //判断是否支持监听事件 ，不支持则停止 if (!doc.addEventListener) return; //注册翻转事件 win.addEventListener(resizeEvt, recalc, false);&#125;)(document, window);","categories":[],"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"http://jiugework.gitee.io/tags/移动端适配/"}]},{"title":"export default和export","slug":"node/模块化","date":"2019-07-05T10:57:42.000Z","updated":"2019-08-26T01:57:01.319Z","comments":true,"path":"2019/07/05/node/模块化/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/node/模块化/","excerpt":"","text":"ES6 ES6中导入模块,使用 import模块名称from ,模块标识符, import ,表示路径 在ES6中,使用export default和export向外露成员 ES6中导入模块,使用 import模块名称from ,模块标识符, import ,表示路径 在ES6中,使用export default和export向外露成员 在一个模块中,可以同时使用export default和export向外暴露成员 export default 在一个模块中, export detault只允许向外暴露1次 1234export default&#123; name:'dsd', sd:'s'&#125; 123import m1 from './aa.js'console.log(m1);// export 使用export向外暴露的成员只能通过{}来接收这种形式叫做 按需导出 export可以暴露多个成员，同时,如果某些成员,我们在import的时候,不需要,则可以不在{}定义 注意:使用export导出的成员,必须严格按照导出时候的名称,来使用 {} 按需接收 使用export 导出的成员,如果就想换个名称来接收,可以使用as来起名 1234567891011export default&#123; name:'dsd', sd:'s'&#125;export var b =&#123; 'zzzzzzz':12&#125;export var b1 =&#123; 'zzzzzzz':12&#125; 1234567import m1,&#123;b,b1 as bs&#125; from './aa.js'console.log(m1);console.log(b);console.log(bs);//&#123;name: \"dsd\", sd: \"s\"&#125;//&#123;zzzzzzz: 12&#125;//&#123;zzzzzzz: 12&#125;","categories":[{"name":"Node","slug":"Node","permalink":"http://jiugework.gitee.io/categories/Node/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jiugework.gitee.io/tags/模块化/"},{"name":"export","slug":"export","permalink":"http://jiugework.gitee.io/tags/export/"}]},{"title":"评论案例","slug":"Vue/评论案例","date":"2019-07-05T10:07:42.000Z","updated":"2019-08-02T14:44:40.381Z","comments":true,"path":"2019/07/05/Vue/评论案例/","link":"","permalink":"http://jiugework.gitee.io/2019/07/05/Vue/评论案例/","excerpt":"","text":"#模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"../node_modules//axios/dist/axios.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"../node_modules/animate.css/animate.css\"&gt; &lt;link rel=\"stylesheet\" href=\"../node_modules/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; img &#123; width: 100%; &#125; .commitBox &#123; width: 500px; margin: 0 auto; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;commit @func='getList'&gt;&lt;/commit&gt; &lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\" v-for=\"(item,i) in list\" ::key=\"item.id\"&gt; &lt;span class=\"badge\"&gt; 评论人 &#123;&#123;item.user&#125;&#125;&lt;/span&gt; &#123;&#123;item.content&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id=\"cn\"&gt; &lt;div class=\"commitBox\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;评论人:&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"user\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;评论内容:&lt;/label&gt; &lt;textarea name=\"\" class=\"form-control\" v-model=\"content\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"button\" class=\"btn btn-primary\" @click=\"add\"&gt;发表&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var commit = &#123; data() &#123; return &#123; content: '', user: '', &#125; &#125;, template: '#cn', methods: &#123; add() &#123; if (!(this.content &amp;&amp; this.user)) return; let list =JSON.parse(localStorage.getItem('list')||'[]') let obj = &#123; id: new Date(), user: this.user, content: this.content &#125;; list.unshift(obj); localStorage.setItem('list',JSON.stringify(list)); console.log(list); this.content = ''; this.user = ''; this.$emit('func'); &#125; &#125;, &#125; let vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: new Date(), user: '简单爱', content: '内容' &#125;, &#123; id: new Date(), user: '将小白', content: '内容' &#125;, &#123; id: new Date(), user: '礼拜', content: '内容' &#125;, ] &#125;, created()&#123; this.getList(); &#125;, methods: &#123; getList()&#123; let list = localStorage.getItem('list')||[]; this.list = JSON.parse(list); &#125; &#125;, components: &#123; commit &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"组件","slug":"组件","permalink":"http://jiugework.gitee.io/tags/组件/"}]},{"title":"父子组件传值","slug":"Vue/父子组件传值","date":"2019-01-05T10:57:42.000Z","updated":"2019-08-16T07:40:20.729Z","comments":true,"path":"2019/01/05/Vue/父子组件传值/","link":"","permalink":"http://jiugework.gitee.io/2019/01/05/Vue/父子组件传值/","excerpt":"","text":"父传子 组件中的所有pzops中的数据,都是通过父组件传递给子组件的 props中的数据,都是只读的,无法重新赋值 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=\"app\"&gt; &lt;son :parentdata='message'&gt;&lt;/son&gt; &lt;!-- parentdata作为子组件的接收值， message为父组件数组作为传给子组件的值 简单来讲 把父组件message的值传给子组件son，son通过 props['parentdata']接收 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'hahah ', &#125;, components:&#123; son:&#123; props:['parentdata'],//只可读不可写 template:`&lt;div&gt;&#123;&#123;parentdata&#125;&#125;&lt;/div&gt;`, &#125; &#125; &#125;)&lt;/script&gt; 父组件传递方法给子组件 父组件可以取到子组件的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div id=\"app\"&gt; &lt;temp1 @func='console'&gt;&lt;/temp1&gt; &lt;/div&gt; &lt;template id=\"temp1\"&gt; &lt;div&gt; 这是子组件 &lt;button @click=\"dd(data)\"&gt;点击打印&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt;let temp1=&#123; template:'#temp1', data() &#123; return &#123; data:&#123; age:188888, name:'zz' &#125; &#125; &#125;, methods: &#123; dd(e)&#123; this.$emit('func',this.data) &#125; &#125;,&#125; let vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; console(data)&#123; console.log(\"打印了父组件的方法\"+data.age); this.obj=data; console.log(this.obj); console.log(vm); &#125; &#125;, components:&#123; temp1, &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"组件传值","slug":"组件传值","permalink":"http://jiugework.gitee.io/tags/组件传值/"}]},{"title":"函数进阶","slug":"js/函数进阶","date":"2018-07-27T14:42:09.000Z","updated":"2019-08-06T09:04:00.515Z","comments":true,"path":"2018/07/27/js/函数进阶/","link":"","permalink":"http://jiugework.gitee.io/2018/07/27/js/函数进阶/","excerpt":"","text":"函数的定义和调用函数定义方式 函数声明方式function关键字(命名函数) 函数表达式(匿名函数) Function里面参数都必须是字符串格式 第三种方式执行效率低,也不方便书写,因此较少使用 所有函数都是Function的实例(对象) 函数属于对象 new Function（’par1’,’par2’…’par..‘,’函数体’） 12let f = new Function('a','b','console.log(a+b)')f(1,2);//3 函数调用方式 普通函数 对象的方法 构造函数 绑定事件函数 定时器函数 立即执行函数 函数this的指向 这些this的指向,是当我们调用函数的时候确定的。调用方式的不同决定了this的指向不同一般指向我们的调用者 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象原型对象里面的方法也指向实例对象 对象方法调用 该方法属于所属对象 事件绑定方法 事件绑定对象 定时器函数 window 立即执行函数 window JavaScript为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部this的指向问题,常用的有bind.call, apply三种方法。 call方法 改变this指向 调用函数 例 1234567891011121314151617181920212223//父构造函数 function Father(name, age) &#123; this.name = name; this.age = age; &#125;; Father.prototype.money=function()&#123; console.log(\"钱\")&#125;; //子构造函数 function Son(name, age, sex) &#123; this.sex = sex Father.call(this, name, age) &#125;; Son.prototype=new Father(); //如果利用对象的形式修改来原型对象，别忘了利用 constructor指回原来的对象 Son.prototype.constructor=Son Son.prototype.play=function()&#123; console.log(\"吃饭\"); &#125; let zs = new Son(\"张三\", 18, 'nan'); zs.money(); zs.play(); console.log(zs); console.log(Father); apply apply方法调用一个函数。简单理解为调用函数的方式,但是它可以改变函数的this指向。 fun.apply(thisArg,[argArray]) thisArg :在fun函数运行时指定的this值 argsArray :传递的值,必须包含在数组里面 返回值就是函数的返回值,因为它就是调用函数 也是调用函数第二个可以改变函数内部的this指向 但是他的参数必须是数组(伪数组) apply的主要应用比如说我们可以利用apply借助于数学内置对象求最大值 123let list=[1,1,5,5,4,54,54,5,48884,4,4545,]; let res= Math.max.apply(Math,list); console.log(res); //48884 bind bind()方法不会调用函数。但是能改变函数内部this指向 fun.bind(thisArg,arg1,arg2...) thisArg :在fun函数运行时指定的this值 arg1 , arg2:传递的其他参数 返回由指定的this值和初始化参数改造的原函数拷贝 1234567891011121314151617 //1let o = &#123; name: '进阶'&#125; function fn() &#123; console.log(this); &#125; let newFn = fn.bind(o); fn(); //指向 --&gt;window newFn(); //指向o//2 let o = &#123; name: '进阶'&#125; function fn(a,b) &#123; console.log(this); console.log(a,b); &#125; let newFn = fn.bind(o,'哈哈','嘻嘻'); fn(); //指向 --&gt;window newFn(); //指向o 返回的是原函数改变this之后产生的新函数 如果有的函数我们不需要立即调用 但是又想改变这个函数内部的this指向此时用bind 例如： 1234567891011121314151617181920212223242526272829303132let btn =document.querySelectorAll('input')[0]btn.onclick=function()&#123; this.disabled=true; this.value='禁用' // setTimeout(()=&gt;&#123; // this.disabled=false // &#125;,3000) setTimeout(function () &#123; this.disabled=false this.value='点击' &#125;.bind(this),3000)&#125;//2.扩展&lt;body&gt; &lt;input type=\"button\" value=\"点击1\"&gt; &lt;input type=\"button\" value=\"点击2\"&gt; &lt;input type=\"button\" value=\"点击3\"&gt; &lt;script&gt; let btns = document.querySelectorAll('input'); for (let i = 0; i &lt; btns.length; i++) &#123; console.log(this); btns[i].onclick = function () &#123; this.disabled = true; this.value = '禁用'+(i+1); setTimeout(function () &#123; this.disabled = false this.value = '点击'+(i+1) &#125;.bind(this), 3000) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 总结相同点： 都可以改变函数内部this指向 区别点: call和apply会调用函数,并且改变函数内部this指向 call和apply传递的参数不一样,call传递参数arg1, arg2.形式apply必须数组形式[arg] bind不会调用函数,可以改变函数内部this指向 主要应用场景: call常做继承. apply经常跟数组有关系.比如借助于数学对象实现数组最大值最小值 bind不调用函数,但是还想改变this指向,比如改变定时器内部的this指向 严格模式JavaScript除了提供正常模式外,还提供了严格模式(strictmode ) , ES5的严格模式是采用具有限制性 Javascript变体的一种方式,即在严格的条件下运行IS代码。 消除了Javascript语法的一些不合理、不严谨之处,减少了一些怪异行为。 消除代码运行的一些不安全之处,保证代码运行的安全。 提高编译器效率,增加运行速度。 禁用了在ECMAScript的未来版本中可能会定义的一些语法,为未来新版本的Javascript做好铺垫。比如一些保留字如: class, enum, export, extends, import, super 不能做变量名 this指向问题 以前在全局作用域函数中的this指向window对象。 严格模式下全局作用域中函数中的this是undefined. 以前构造函数时不加new也可以调用,当普通函数, this指向全局对象 严格模式下,如果构造函数不加new调用, thi指向undefined给他赋值会报错 new实例化的构造函数指向创建的对象实例。 定时器this还是指向window 事件.对象指向调用者 函数变化 函数不能有重名的参数。 函数必须声明在顶层新版本的JavaScript会引入”块级作用域” (ES6中已引入)。为了与新版本接轨,不允许在非函数的代码块内声明函数。 高阶函数 高阶函数是对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出。 12345678fn1 = function () &#123; console.log(\"最后调用\"); &#125; function fn(a, b, callback) &#123; console.log(a + b); callback &amp;&amp; callback() &#125; fn(1, 2, fn1); 此时fn就是一个高阶函数 函数也是一种数据类型,同样可以作为参数,传递给另外一个参数使用。最典型的就是作为回调函数。 闭包 闭包(closure )指有权访问另一个函数作用域中变量的函数—– JavaScript高级程序设计。 简单理解就是,一个作用域可以访问另外一个函数内部的局部变量。 1234567891011121314 function fn() &#123; var num =10; return function (params) &#123; console.log(num); &#125;; &#125; var f= fn(); f()//类似于f= function (params) &#123; console.log(num); &#125;;f(); 闭包的作用：延伸了变量的作用范围 闭包案例 循环注册点击事件 注意这里for里面是用var声明的 123456789101112131415&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; &lt;script&gt; let lis= document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; (function(i)&#123; lis[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i); &#125; &lt;/script&gt; 循环setTimeout 3秒之后打印出li元素的所有内容 123456789 let lis= document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123;(function(a)&#123; setTimeout(function()&#123; console.log(lis[a].innerHTML); &#125;,3000) &#125;)(i); &#125;//1 2 3 闭包总结 什么是闭包 ​ 闭包是一个函数(一个作用域可以访问另外一个函数的局部变量) 闭包的作用是是嗯嘛 延伸变量的作用范围 递归什么是递归? 如果一个函数在内部可以调用其本身,那么这个函数就是递归函数。 简单理解:函数内部自己调用自己这个函数就是递归函数 递归函数的作用和循环效果一样 由于递归很容易发生”栈溢出”错误(stackoverflow ) ,所以必须要加退出条件return 12345678let num = 0; function fn() &#123; num++; console.log(num); if (num &gt;= 10) return num fn() &#125; fn(); 利用递归求阶乘 12345678function fn(n) &#123; if (n == 1) &#123; return n &#125; return n * fn(n - 1) &#125; f = fn(3); console.log(f); 利用递归函数求斐波那契数列(兔子序列) 1234567 function fb(n) &#123; if(n==1||n==2)&#123; return 1; &#125; return fb(n - 1) + fb(n - 2) &#125;console.log( fb(6));//8 拷贝浅拷贝 浅拷贝只是拷贝最外面一层,更深层次对象级别的只拷贝引用. 浅拷贝只是拷贝最外面一层，更深的只是拷贝的地址 Object.assign(target….sources) es6新增方法可以浅贝 深拷贝 深拷贝拷贝多层每一级别的数据都会拷贝 深拷贝会复制一个空间/地址 1234567891011121314151617181920212223242526let od = &#123; name:'18', sex:&#123; sex:88888 &#125;&#125;let ne=&#123;&#125;//封装 function deepCopy(newobj, oldobj) &#123; for (let k in oldobj) &#123; let item = oldobj[k]; if (item instanceof Array) &#123; deepCopy(newobj[k], item) &#125; else if (item instanceof Object) &#123; newobj[k] = &#123;&#125;; deepCopy(newobj[k], item) &#125;else&#123; newobj[k]=item &#125; &#125; &#125;deepCopy(ne,od);console.log(od);console.log(ne);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"函数进阶","slug":"函数进阶","permalink":"http://jiugework.gitee.io/tags/函数进阶/"}]},{"title":"数据交互","slug":"data/数据交互","date":"2018-07-11T08:25:28.000Z","updated":"2019-07-11T09:56:39.965Z","comments":true,"path":"2018/07/11/data/数据交互/","link":"","permalink":"http://jiugework.gitee.io/2018/07/11/data/数据交互/","excerpt":"","text":"http协议 无状态 连接过程：连接-接受-发送请求 消息分成两部分，请求头&lt;=32K、请求体&lt;=2G form 最重要 action-提交到的位置 method–GET/POST/PUT/DELETE/HEAD GET: 把数据放在url传输 数据量很小、缓存。获取东西 POST: 把数据放在请求体里面 数据量大、不会缓存。发送东西，大量发送。 PUT:发送东西，大量发送。 DELETE:删除。 HEAD:让服务器只发送头回来就行(不需要内容) name 名字 enctype 上传文件需要设置的 ajax 官方、不能跨域 单向 ajax好: 用户体检好，性能高原理 ajax-jsonp 民间、能跨域 不推荐 破坏了http自身的设计websocket 双向-数据实时性 html5 IE9+ 用的非常广 基于http 跨域 原生麻烦socket.io: 兼容的？ 二进制数据 怎么用 聊天室 视频点播socket.io 安装npm i socket.io -D websocket聊天室 用户注册、登陆 发言 离线消息 数据 用户信息库 消息数据库 数据库 关系形数据库—— MySQL、Oracle 优点 : 强大 缺点 : 性能低 文件形数据库—— SQLite 优点 : 简单 缺点 : 支撑不了庞大的应用、没法储存特别多的数据 文档形数据库—— MongoDB 优点 : 直接存储对象本身 缺点 : 不够严谨、性能偏低 空间形数据库—— 坐标、位置 .. GIS 数据库类型: 数字 整数 thinyint(-128~127或者0~255)、int(21亿或43亿); 浮点数 float（保留到小数点8位） 、 double（308） 字符串 小字符串 varchar（255） 大字符串 text（2G） 主键: 唯一 性能高","categories":[],"tags":[{"name":"请求数据","slug":"请求数据","permalink":"http://jiugework.gitee.io/tags/请求数据/"},{"name":"ajax","slug":"ajax","permalink":"http://jiugework.gitee.io/tags/ajax/"}]},{"title":"数据遍历","slug":"js/遍历方法","date":"2018-07-08T09:27:42.000Z","updated":"2019-08-06T09:02:16.859Z","comments":true,"path":"2018/07/08/js/遍历方法/","link":"","permalink":"http://jiugework.gitee.io/2018/07/08/js/遍历方法/","excerpt":"","text":"map 映射 一个对一个 123456789101112 [12,58,60,60,99,8] [\"不及格\",\"不及格\",\"及格\",\"及格\",\"及格\",\"不及格\"];// 1.使arr中数字乘以2，输出结果let arr = [12, 5, 8];let result = arr.map(item =&gt; item * 2)console.log(result);//(3) [24, 10, 16]// ////////////////////// 2.分数大于等于60的输出及格,小于60的输出不及格let mark = [15, 88, 76, 60, 55];let markResult = mark.map(item=&gt; item &gt;= 60 ? \"及格\" : \"不及格\")console.log(markResult);//[\"不及格\", \"及格\", \"及格\", \"及格\", \"不及格\"] reduce 汇总 一堆出来一个1234567891011121314151617// 1.算个总数 [10,20,30] =&gt; 60;// 2.算个平均数 [10,20,30] =&gt; 20; let arr = [12, 541, 5461, 115, 656]; let arrRes = arr.reduce((tmp, item, index) =&gt; tmp + item)console.log(arrRes);//6785//2.算个平均数let avgRes = arr.reduce((tmp, item, index) =&gt; &#123; if (index != arr.length - 1) &#123; return tmp + item &#125; else &#123; return (tmp + item) / arr.length; &#125;&#125;)console.log(avgRes);//1357 filterarray.filter(function(currentValue,index,arr){}) filter方法创建一个新的数组,新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛造数组 注意它直接返回一个新数组 不会收到return的影响 currentValue:数组当前项的值 index数组当前项的索 arr:数组对象本身 12345678910111213 // 1.算出能被3整除的数let arr = [12, 541, 5461, 115, 656, 99, 30];let result = arr.filter(item =&gt; item%3==0)console.log(result); //(3) [12, 99, 30]// 2.价格大于10000的数据let arrz=[ &#123;title:'男鞋',price:650&#125;, &#123;title:'女鞋',price:15000&#125;, &#123;title:'男装',price:100&#125;, &#123;title:'女装',price:10000&#125;]let pres = arrz.filter(item=&gt;item.price&gt;=10000);console.log(pres);// &#123;title:'女鞋',price:15000&#125;, &#123;title:'女装',price:10000&#125; fofEach 循环(迭代) orEach这种方法也有一个小缺陷：你不能使用break语句中断循环，也不能使用return语句返回到外层函数。 forEach(function(value,索引，数组本身){}) 12let arr = [12, 541, 99, 30]; arr.forEach(item=&gt; console.log(item)) Somearray.some(function(currentValue,index,arr)) some方法用于检测数组中的元素是否满足指定条件,通俗点查找数组中是否有满足条件的元素 注意它返回值是布尔值,如果查找到这个元素,就返回true,如果查找不到就返回false. 如果找到第一个满足条件的元素,则终止循环不在继续查找 currentValue:数组当前项的值 index:数组当前项的索引 arr :数组对象本身 123let arr = [12, 541, 656, 99, 30]; let res= arr.some(item=&gt;item==12); console.log(res); //true 123456789101112let arr = [111,12, 541, 5461, 115, 656, 99, 30]; let res = arr.some(item =&gt; &#123; if (item == 12) &#123; console.log(\"找到来\"); return true; //找到了记得return 不然他会找把整个数组找完 &#125; console.log(\"寻找\"); &#125; ); console.log(res); 数组遍历普通for循环，经常用的数组遍历12345var arr = [1, 3, 45, 7, 'dd'];for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125;// 打印结果 1 3 45 7 dd 优化版for循环:使用变量，将长度缓存起来，避免重复获取长度，数组很大时优化效果明显 12345var arr = [1, 3, 45, 7, 'dd'];for(var j= 0, len = arr.length; j&lt;len; j++)&#123; console.log(arr[j]); &#125;// 打印结果 1 3 45 7 dd map遍历 map即是 “映射”的意思 用法与 forEach 相似 12345678910 var arr = [1, 3, 45, 7, 'dd'];arr.map(function(value,i)&#123; console.log(i+'--'+value);&#125;)// 打印结果// 0--1// 1--3 // 2--45 // 3--7 // 4--dd map遍历支持使用return语句，支持return返回值1234567var arr = [1, 3, 45, 7, 'dd'];var b= arr.map(function(value,i)&#123; console.log(i+'--'+value); return value;&#125;)console.log(b);// b返回 (5) [1, 3, 45, 7, \"dd\"] for-of遍历 是ES6新增功能123456var arr = [1, 3, 45, 7, 'dd'];for( let i of arr)&#123; console.log(i);&#125;// 打印结果: 1 3 45 7 dd for-of这个方法避开了for-in循环的所有缺陷 与forEach()不同的是，它可以正确响应break、continue和return语句 for-of循环不仅支持数组，还支持大多数类数组对象 for-of循环也支持字符串遍历","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"遍历","slug":"遍历","permalink":"http://jiugework.gitee.io/tags/遍历/"},{"name":"循环","slug":"循环","permalink":"http://jiugework.gitee.io/tags/循环/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"}]},{"title":"ES5中新增的方法","slug":"js/对象","date":"2018-07-08T09:27:42.000Z","updated":"2019-07-27T08:30:25.299Z","comments":true,"path":"2018/07/08/js/对象/","link":"","permalink":"http://jiugework.gitee.io/2018/07/08/js/对象/","excerpt":"","text":"对象方法Object.defineProperty（）定义对象中新属性或修改原有的属性。 Object.defineProperty（obj,prop,des） obj:必需。目标对象 prop :必需。需定义或修改的属性的名 descriptor :必需。目标属性所拥有的特性 Object.defineProperty()第三个参数descriptor说明:以对象形式(}书写 value:设置属性的值默认为undefinedwritable:值是否可以重写truel false默认为false enumerable:目标属性是否可以被枚举。true | false默认为false configurable:目标属性是否可以被删除或是否可以再次修改特性true | false默认为false Object.keys()用于获取对象自身所有的属性 12345let obj=&#123; name:'小米', age:9, &#125; console.log( Object.keys(obj));//[\"name\", \"age\"]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES5新增方法","slug":"ES5新增方法","permalink":"http://jiugework.gitee.io/tags/ES5新增方法/"}]},{"title":"Promise","slug":"js/Promise","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:15:58.112Z","comments":true,"path":"2018/07/05/js/Promise/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/Promise/","excerpt":"","text":"异步: 操作直接没啥关系,同时进行多个操作，代码复杂。 同步: 同时只能做一件事 代码简单。 本质：等待异步操作结束 当状态改变的时候—调用之前挂起的then队列 then的时候直接执行对应的函数，并且参数给人家。 Promise 用法Promise.all 一个都不能错Promise.race 只要有一个对 一个 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise(function (resolve, reject) &#123; //异步代码 //resolve 成功 //reject 失败 $.ajax(&#123; url: \"data/tt.txt\", dataType: \"json\", success: function (data) &#123; resolve(data) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;) p.then(function (data) &#123; alert('成功' + data) // 调用成功 &#125;, function (err) &#123; console.log(err); alert('失败') //失败了 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function createPromise(url) &#123; return new Promise(function (resolve, reject) &#123; //异步代码 //resolve 成功 //reject 失败 $.ajax(&#123; url, dataType: \"json\", success: function (data) &#123; resolve(data) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;) &#125; Promise.all([ createPromise('data/tt.txt'), createPromise('data/jj.txt') ]).then(function (arr) &#123; // 全部成功 alert('成功'); let [arr1, arr2] = arr; console.log(arr); console.log(arr1); console.log(arr2); &#125;, function (err) &#123; //失败一个或多个 alert('失败'); console.log(err); &#125;) &lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123; url: 'data/tt.txt', dataType: \"json\" &#125;), $.ajax(&#123; url: 'data/jj.txt', dataType: \"json\" &#125;) ]) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jq中的promise 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"js/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url:'data/tt.txt',dataType: \"json\"&#125;), $.ajax(&#123;url:'data/jj.txt',dataType: \"json\"&#125;) ]).then(function (arr) &#123; let [arr1,arr2] = arr; alert('成功'); console.log(arr); console.log(arr1); console.log(arr2); &#125;,function () &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"}]},{"title":"模块化","slug":"js/模块化","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:53:42.647Z","comments":true,"path":"2018/07/05/js/模块化/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/模块化/","excerpt":"","text":"模块化 模块-组件-元件 模块： 12345678910// - 定义: model.js define(function (require,exports,module) &#123; exports.a = 12; exports.b=5;&#125;); // - 调用: xx.htmlseajs.use(['xxxx.js','xxx.js',...],function(model1,model2,...)&#123;&#125;) 民间的–sea.js 、require.js CMD、AMD规范 区别： html-&gt;js use js-&gt; js require node.js模块化 没有define exports、require、module 引用自定义模块 1) 放到node_modules里, 2)前面加上./ 引入: let mod = require(‘./aaa.js’) 输出: exports.xx = xxx; module.exports={x,x,x,y} ES6模块化 import export 引入:impo mod from = ‘./xx.js’ 输出:expor{x,x,x}","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"模块化","slug":"模块化","permalink":"http://jiugework.gitee.io/tags/模块化/"}]},{"title":"generator","slug":"js/generator","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:33:28.680Z","comments":true,"path":"2018/07/05/js/generator/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/generator/","excerpt":"","text":"generatorgenerator-生成器 普通函数- 一路到底 generator函数- 中间可以停 走走停停 12345678910 function *show() &#123; alert('a'); yield; alert('b') &#125; show(); let gentObj = show(); gentObj.next(); //a gentObj.next();//bconsole.log(gentObj) generator-yield是什么 可以传参、可以返回 …..本质：无感觉处理异步操作","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"generator","slug":"generator","permalink":"http://jiugework.gitee.io/tags/generator/"}]},{"title":"Vue过滤器","slug":"Vue/Vue过滤器","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-29T14:24:37.660Z","comments":true,"path":"2018/07/05/Vue/Vue过滤器/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/Vue/Vue过滤器/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &#123;&#123; message | formatTime(&apos;YMD&apos;)&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; message | formatTime(&apos;YMDHMS&apos;)&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; message | formatTime(&apos;HMS&apos;)&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; message | formatTime(&apos;YM&apos;)&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //实现vue中的过滤器功能 先定义过滤器 在使用 value是过滤器前面的值，type是过滤器中定义的字段 //这个过滤器是全局的 局部是vm的实例下filters：&#123;xx ：fn（x,y）&#123;&#125;&#125; Vue.filter(&quot;formatTime&quot;, function (value, type) &#123; var dataTime = &quot;&quot;; var data = new Date(); data.setTime(value); var year = data.getFullYear(); var month = data.getMonth() + 1 var day = data.getDate(); var hour = data.getHours(); var minute = data.getMinutes(); var second = data.getSeconds(); [year,month, day, hour, minute,second,]=[year,month, day, hour, minute,second].map(item=&gt;item&gt;10?item:&apos;0&apos;+item) if (type == &quot;YMD&quot;) &#123; dataTime = year + &quot;-&quot; + month + &quot;-&quot; + day; &#125; else if (type == &quot;YMDHMS&quot;) &#123; dataTime = year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second; &#125; else if (type == &quot;HMS&quot;) &#123; dataTime = hour + &quot;:&quot; + minute + &quot;:&quot; + second; &#125; else if (type == &quot;YM&quot;) &#123; dataTime = year + &quot;-&quot; + month; &#125; return dataTime;//将格式化后的字符串输出到前端显示 &#125;); var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;1501068985877&apos; &#125; &#125;); &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"过滤器","slug":"过滤器","permalink":"http://jiugework.gitee.io/tags/过滤器/"}]},{"title":"箭头函数","slug":"js/箭头函数","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:53:42.648Z","comments":true,"path":"2018/07/05/js/箭头函数/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/箭头函数/","excerpt":"","text":"之前的函数是这样写的 123function 名字()&#123; // code&#125; 而ES6是↓ 箭头函数 如果只有一个参数，()可以省略 如果只有一个return {}可以省略 1234567891011121314151617()=&gt;&#123; &#125;;window.onload= ()=&gt; alert('vb');let show=function()&#123; console.log(\"666\");&#125;;let show=()=&gt;&#123; console.log(\"666\");&#125;;let add = function(a,b)&#123; alert(a+b);&#125;let add = (a,b)=&gt;&#123; alert(a+b);&#125;add(1,6) 函数-有参数 参数扩展/展开 收集参数 收集剩余的参数 …args必须是最后一个123456789function arg(a,b,...args) &#123; console.log(a); console.log(b); console.log(...args);&#125;arg(1,2,5,7,9,2,10); // 1// 2// 5 7 9 2 10 展开参数 12345678910111213141516171819202122232425 let array = [1,55,5]function zhan(a,b,c) &#123; console.log(a); console.log(b); console.log(c);&#125;zhan(...array) //1//55//5//////////////////////////////////let arr1=[1,2,5];let arr2=[10,22,52];let arr3 = [...arr1,...arr2];console.log(arr3);// (6) [1, 2, 5, 10, 22, 52]////////////////////////////////// function a(...args)&#123; fadd(...args) &#125; function fadd(a,b) &#123; console.log(a+b); &#125; a(1,6)//7 默认参数 123456function m(a,b=1,c=10) &#123; console.log(a,b,c); &#125; m(1) //1 1 10 m(1,2)//1 2 10 m(1,2,5)// 1 2 5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"}]},{"title":"解构赋值","slug":"js/结构赋值","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-11T09:55:59.502Z","comments":true,"path":"2018/07/05/js/结构赋值/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/结构赋值/","excerpt":"","text":"结构赋值 左右两边结构必须一样; 右边必须是个东西; 声明和赋值不能分开(必须在一句话里说完);12345678 // 数组let [aq,bq,cq]=[1,2,3]; console.log(aq);//1 console.log(bq);//2 console.log(cq);//3 // 对象 let &#123;w,z,y&#125; = &#123;w:12,z:66,y:15&#125;; console.log(w,z,y);// 12 66 15","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jiugework.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/tags/JavaScript/"}]},{"title":"命名视图","slug":"Vue/命名视图","date":"2018-07-05T10:57:42.000Z","updated":"2019-08-03T07:39:42.333Z","comments":true,"path":"2018/07/05/Vue/命名视图/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/Vue/命名视图/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"../node_modules//axios/dist/axios.js\"&gt;&lt;/script&gt; &lt;script src=\"../node_modules/vue-router/dist/vue-router.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"../node_modules/animate.css/animate.css\"&gt; &lt;link rel=\"stylesheet\" href=\"../node_modules/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0 auto; &#125; .top &#123; width: 100%; height: 50px; border: 5px solid #333; text-align: center; line-height: 50px; font-size: 30px; &#125; .left &#123; position: absolute; left: 0; top: 80px; width: 200px; height: 100%; text-align: center; border: 5px solid #333; &#125; .right &#123; text-align: center; position: absolute; left:220px; top: 80px; width: 100%; height: 100%; border: 5px solid #333; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-view &gt;&lt;/router-view&gt; &lt;router-view name=\"left1\"&gt;&lt;/router-view&gt; &lt;router-view name=\"right1\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=\"top\"&gt; &lt;div class=\"top\"&gt; top &lt;/div&gt; &lt;/template&gt; &lt;template id=\"left\"&gt; &lt;div class=\"left\"&gt; left &lt;/div&gt; &lt;/template&gt; &lt;template id=\"right\"&gt; &lt;div class=\"right\"&gt; right &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var top1 = &#123; template: '#top', &#125;; var left1 = &#123; template: '#left', &#125;; var right1 = &#123; template: '#right', &#125;; var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default:top1, left1, right1, &#125; &#125;, // &#123; path: '/left', component: left1, name: left1 &#125;, // &#123; path: '/right', component: right1, name: right1 &#125;, ] &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ds' &#125;, router &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://jiugework.gitee.io/categories/Vue/"}],"tags":[{"name":"命名视图","slug":"命名视图","permalink":"http://jiugework.gitee.io/tags/命名视图/"},{"name":"Router","slug":"Router","permalink":"http://jiugework.gitee.io/tags/Router/"}]},{"title":"变量let与常量const","slug":"js/变量与常量","date":"2018-07-05T10:57:42.000Z","updated":"2019-07-28T01:35:16.826Z","comments":true,"path":"2018/07/05/js/变量与常量/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/变量与常量/","excerpt":"","text":"变量let与常量const ES5 var 问题 可以重复声明 无法限制修改 没有块级作用域 ES6 变量 let 不能重复声明 可以重新定义 有块级作用域 ES6 常量 const 不能重复声明 不可以重新定义 有块级作用域","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"变量","slug":"变量","permalink":"http://jiugework.gitee.io/tags/变量/"}]},{"title":"Git常用操作","slug":"GIt操作","date":"2018-07-05T10:57:42.000Z","updated":"2019-08-26T01:55:25.031Z","comments":true,"path":"2018/07/05/GIt操作/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/GIt操作/","excerpt":"","text":"初始化git config --global user.name &quot;你的账号&quot; git config --global user.email &quot;你的邮箱&quot; 在文件中初始化Git（创建Git仓库）git init 提交仓库 创建文件 git touch a1.html 文件提交到暂存区 git add a1.html 文件提交描述 git commit -m &#39;描述&#39; 查看文件状态 git status 提交到仓库 git push Git克隆操作 git clone 仓库地址 新仓库添加本地文件 新建码云/github仓库 本地新建文件夹 新建的文件夹，点击鼠标右键，选择git bash here git init 复制项目地址 然后git remote add origin 地址 继续输入git pull origin master 命令，将码云上的仓库pull到本地文件夹 使用git add -A （. 表示所有的）或者 git add + 文件名 // 将文件保存到缓存区 使用git commit -m‘新添加的文件内容描述’ //添加文件描述 使用git push origin master ，将本地仓库推送到远程仓库 ok了 创建分支 找到gitee/github分支-新建分支或者git checkout -b 新分支名 本地git pull拉取最新代码 查看分支git branch 切换本地分支git checkout 分支名 切换分支git checkout 分支名字 合并线上分支到master 切换到master git checkout master 合并git merge origin/分支名","categories":[{"name":"Git","slug":"Git","permalink":"http://jiugework.gitee.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jiugework.gitee.io/tags/Git/"}]},{"title":"Number","slug":"js/number","date":"2018-07-05T10:01:48.000Z","updated":"2019-07-24T03:13:34.007Z","comments":true,"path":"2018/07/05/js/number/","link":"","permalink":"http://jiugework.gitee.io/2018/07/05/js/number/","excerpt":"","text":"保留2位小数 四舍五入 12var num =2.446242342;num = num.toFixed(2); // \b输出结果为 2.45 不四舍五入 1Math.floor(15.7784514000 * 100) / 100 // \b输出结果为 15.77","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiugework.gitee.io/categories/JavaScript/"}],"tags":[{"name":"Number","slug":"Number","permalink":"http://jiugework.gitee.io/tags/Number/"}]}]}